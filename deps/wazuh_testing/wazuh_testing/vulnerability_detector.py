# Copyright (C) 2015-2020, Wazuh Inc.
# Created by Wazuh, Inc. <info@wazuh.com>.
# This program is free software; you can redistribute it and/or modify it under the terms of GPLv2

import re
import os
import sqlite3
import datetime
from collections import namedtuple
from wazuh_testing.tools import WAZUH_PATH

PACKAGES_DB_PATH = "{}/queue/db/".format(WAZUH_PATH)
CVE_DB_PATH = "{}/queue/vulnerabilities/cve.db".format(WAZUH_PATH)

UpdateFromYearResult = namedtuple('UpdateFromYearResult', 'result actual_provider actual_update_from')

nvd_check_feed_download_regex = r'.* wazuh-modulesd.*Downloading.*nvd\.nist\.gov\/feeds.*-(.*)\.(json|meta).*'

vulnerability_detector_prefix = r'.*wazuh-modulesd:vulnerability-detector.*'


def callback_detect_vulnerability_scan_started(line):
    msg = r'.*wazuh-modulesd:vulnerability-detector.* INFO:.*Starting vulnerability scanning'
    match = re.match(msg, line)

    return match is not None


def callback_detect_vulnerability_scan_finished(line):
    msg = r'.*wazuh-modulesd:vulnerability-detector.* INFO:.*Vulnerability scanning finished'
    match = re.match(msg, line)
    return match is not None


def callback_detect_vulnerability_scan_sleeping(line):
    msg = r'.*wazuh-modulesd:vulnerability-detector.* Sleeping for (.*)...'
    match = re.match(msg, line)

    return match.group(1) if match is not None else ""


def callback_detect_update_from_year_result(line):
    invalid_year_msg = r'.*wazuh-modulesd.*wmodules-vuln-detector.*ERROR: Invalid content for \'update_from_year\' option at module \'vulnerability-detector\''
    invalid_year_match = re.match(invalid_year_msg, line)

    if invalid_year_match is not None:
        return UpdateFromYearResult("invalid_year", None, None)

    provider_added_msg = r'.*wazuh-modulesd.*Added (.*) feed.*Update since: (.*)\.'
    provider_added_match = re.match(provider_added_msg, line)

    if provider_added_match is not None:
        return UpdateFromYearResult("provider_added", provider_added_match.group(1), int(provider_added_match.group(2)))

    return None


def callback_download_redhat_feed_from_year(line):
    download_redhat_from_msg = r'.*wazuh-modulesd.*vulnerability-detector.*download.*access\.redhat\.com.*after=(.*)-.*-.*'
    download_redhat_from_match = re.match(download_redhat_from_msg, line)

    download_nvd_from_match = re.match(nvd_check_feed_download_regex, line)

    if download_redhat_from_match is not None:
        return int(download_redhat_from_match.group(1))
    elif download_nvd_from_match is not None:
        return int(download_nvd_from_match.group(1))
    else:
        return None


def callback_detect_vulnerability_detector_disabled(line):
    msg = r'(.*)wazuh-modulesd:vulnerability-detector(.*)DEBUG: Module disabled. Exiting...'
    match = re.match(msg, line)

    return match is not None


def callback_detect_vulnerability_detector_enabled(line):
    msg = r'(.*)wazuh-modulesd:vulnerability-detector(.*)'
    match1 = re.match(msg, line)
    msg = r'(.*)DEBUG: Module disabled. Exiting...(.*)'
    match2 = re.match(msg, line)

    return match1 is not None and match2 is None


def callback_detect_os_parameter_warning(line):
    msg = r'.*wazuh-modulesd.*wmodules-vuln-detector.*WARNING.*\'os\'.*single-provider.*'
    match = re.match(msg, line)
    return match is not None


def make_vuln_callback(pattern):
    """
    Creates a callback function from a text pattern.

    It already contains the vulnerability-detector prefix.

    Parameters
    ----------
    pattern : str
        String to match on the log

    >>> callback_bionic_update_started = make_callback("Starting Ubuntu Bionic database update")
    """
    pattern = r'\s+'.join(pattern.split())
    regex = re.compile(r'{}{}'.format(vulnerability_detector_prefix, pattern))

    return lambda line: regex.match(line) is not None


def load_db(db_path):
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    return conn, cursor


def make_query(db_path, query_list):
    """
    Makes a query to the database in db_path for each item in query_list
    """
    try:
        db = load_db(db_path)
        for item in query_list:
            db[1].execute(item)
        db[0].commit()
    except sqlite3.Error as error:
        print("Failed perform sqlite query\n", error)
        raise error
    finally:
        db[1].close()
        db[0].close()



def insert_package_in_db(agent = "000", format = "rpm", name = "WazuhIntegrationPackage", 
    priority = "", section = "Unspecified", size= 99, vendor = "WazuhIntegrationTests", version = "1.0.0-1.el7",
    architecture = "x86_64", multiarch = "", description = "Wazuh Integration tests mock package", 
    source = "Wazuh Integration tests mock package", location = "", triaged = 0, cpe = "",
    install_time = datetime.datetime.now().strftime("%Y/%m/%d %H:%M:%S")
):
    """
    Insert a new package in the installed package database, with the parameters given as arguments.
    If used in conjunction with insert_vulnerability using the default arguments it will generate an alert.
    """
    path =  os.path.join(PACKAGES_DB_PATH,"{}.db".format(agent))
    query_string = """INSERT INTO sys_programs
        (scan_id, scan_time, format, name, priority, section, size, vendor, install_time, version, \
            architecture, multiarch, source, description, location, triaged, cpe)
        select scan_id, scan_time, \"{}\", \"{}\", \"{}\", \"{}\", \"{}\", \"{}\", 
        \"{}\", \"{}\", \"{}\",  \"{}\", \"{}\", \"{}\", \"{}\", \"{}\", \"{}\"
        from sys_programs limit 1
        """.format(
            format, name, priority, section, size, vendor, install_time, version, architecture, 
            multiarch, source, description, location, triaged, cpe
        )
    make_query(path, [query_string])
        


def insert_vulnerability(cveid = "WVE-000", target = "RHEL7", target_minor= "", pending = 0, 
    package = "WazuhIntegrationPackage", operation = "less than", operation_value = "2.0.0-1.el7",
    title = "", severity = "critical", published =  datetime.datetime.now().strftime("%Y-%m-%dT%H:%M:%SZ"),
    updated = "", reference = "https://github.com/wazuh/wazuh-qa", target_v = "REDHAT", cvss = "10.000000", 
    cvss_vector = "AV:N/AC:L/Au:N/C:C/I:C/A:C", rationale = "Wazuh integration test vulnerability", 
    CVSS3 = "", bugzilla_reference = "https://github.com/wazuh/wazuh-qa", cwe = "WVE-000 -> WVE-001", 
    advisories = "RHSA-2010:0029"
):
    """
    Insert a new vulnerability in the database of vulnerabilities, with the parameters given as arguments.
    If used in conjunction with insert_package_in_db using the default arguments it will generate an alert.
    """
    vulnerabilities_query_string = """INSERT INTO VULNERABILITIES
        (cveid, target, target_minor, pending, package, operation, operation_value)
        VALUES 
        (\"{}\", \"{}\", \"{}\", \"{}\", \"{}\", \"{}\", \"{}\")""".format(
            cveid, target, target_minor, pending, package, operation, 
            operation_value
        )
    query_vulnerabilities_info_query_string = """INSERT INTO VULNERABILITIES_INFO 
        (ID, title, severity, published, updated, reference, target, rationale, cvss, cvss_vector, CVSS3, \
            bugzilla_reference, cwe, advisories)
        VALUES 
        (\"{}\", \"{}\", \"{}\", \"{}\", \"{}\", \"{}\", \"{}\", \"{}\", \"{}\", \"{}\", \"{}\", \"{}\", \"{}\", \
        \"{}\")""".format(
            cveid, title, severity, published, updated, reference, target_v, rationale, cvss, cvss_vector, CVSS3, 
            bugzilla_reference, cwe, advisories
        )
    make_query(CVE_DB_PATH, [vulnerabilities_query_string, query_vulnerabilities_info_query_string])


def update_package(version, package, agent = "000"):
    """
    Update version of installed package in databas.
    Used to simulate upgrades and downgrades of the package given as argument.
    """
    path =  os.path.join(PACKAGES_DB_PATH,"{}.db".format(agent))
    update_query_string = "update sys_programs set version=\"{}\" where name=\"{}\";".format(version, package)
    make_query(path, [update_query_string])
