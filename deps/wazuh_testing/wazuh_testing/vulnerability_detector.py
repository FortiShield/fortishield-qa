# Copyright (C) 2015-2021, Wazuh Inc.
# Created by Wazuh, Inc. <info@wazuh.com>.
# This program is free software; you can redistribute it and/or modify it under the terms of GPLv2

import datetime
import json
import os
import re
import sqlite3
import random
from time import time, sleep

from wazuh_testing.tools import WAZUH_PATH
from wazuh_testing.tools import file
from wazuh_testing.tools.services import control_service, check_if_process_is_running

VULN_DETECTOR_GLOBAL_TIMEOUT = 20
VULN_DETECTOR_SCAN_TIMEOUT = 40
DEBIAN_IMPORT_FEED_TIMEOUT = 50

DB_PATH = f"{WAZUH_PATH}/queue/db/"
CVE_DB_PATH = f"{WAZUH_PATH}/queue/vulnerabilities/cve.db"
GLOBAL_DB_PATH = f"{WAZUH_PATH}/queue/db/global.db"
MSU_PATH = f"{WAZUH_PATH}/queue/vulnerabilities/dictionaries/msu.json.gz"
CPE_HELPER_PATH = f"{WAZUH_PATH}/queue/vulnerabilities/dictionaries/cpe_helper.json"
DEFAULT_PACKAGE_NAME = "wazuhintegrationpackage"
DEFAULT_VULNERABILITY_ID = "WVE-000"
CLIENT_KEYS_PATH = '/var/ossec/etc/client.keys'

MOCKED_AGENT_NAME = 'mocked_agent'
CVE_NUM_TABLES = 24

REAL_NVD_FEED = 'real_nvd_feed.json'
CUSTOM_NVD_FEED = 'custom_nvd_feed.json'
CUSTOM_REDHAT_JSON_FEED = 'custom_redhat_json_feed.json'
CUSTOM_REDHAT_OVAL_FEED = 'custom_redhat_oval_feed.xml'
CUSTOM_CANONICAL_OVAL_FEED = 'custom_canonical_oval_feed.xml'
CUSTOM_DEBIAN_OVAL_FEED = 'custom_debian_oval_feed.xml'
CUSTOM_DEBIAN_JSON_FEED = 'custom_debian_json_feed.json'
CUSTOM_NVD_VULNERABILITIES_1 = 'nvd_vulnerabilities_1.json'
CUSTOM_NVD_VULNERABILITIES_2 = 'nvd_vulnerabilities_2.json'
CUSTOM_MSU_JSON_FEED = 'custom_msu.json'
INVALID_RHEL_FEEDS_CONF = 'wazuh_invalid_redhat_feed.yaml'
INVALID_CANONICAL_FEEDS_CONF = 'wazuh_invalid_canonical_feed.yaml'
INVALID_DEBIAN_FEEDS_CONF = 'wazuh_invalid_debian_feed.yaml'
INVALID_MSU_FEEDS_CONF = 'wazuh_invalid_msu_feed.yaml'

REDHAT_NUM_CUSTOM_VULNERABILITIES = 1
CANONICAL_NUM_CUSTOM_VULNERABILITIES = 1
DEBIAN_NUM_CUSTOM_VULNERABILITIES = 3
NVD_NUM_CUSTOM_VULNERABILITIES = 5

SYSTEM_DATA = {
    "RHEL8": {"target": "RHEL8", "os_name": "CentOS Linux", "os_major": "8", "os_minor": "1", "name": "centos8"},
    "BIONIC": {"target": "BIONIC", "os_name": "Ubuntu", "os_major": "18", "os_minor": "04", "name": "Ubuntu-bionic"},
    "BUSTER": {"target": "BUSTER", "os_name": "Debian GNU/Linux", "os_major": "10", "os_minor": "0", "name": "debian10"}
}

NVD_LOG = 'National Vulnerability Database'
REDHAT_LOG = 'Red Hat Enterprise Linux'
BIONIC_LOG = 'Ubuntu Bionic'
BUSTER_LOG = 'Debian Buster'
MSU_LOG = 'Microsoft Security Update'
CUSTOM_MSU = 'custom_msu.json'
CUSTOM_CPE_HELPER = 'custom_cpe_helper.json'
VULNERABILITIES = 'vulnerabilities.json'

NVD_TABLES = [
    {"name": "NVD_REFERENCE", "path": CVE_DB_PATH},
    {"name": "NVD_METRIC_CVSS", "path": CVE_DB_PATH},
    {"name": "NVD_METADATA", "path": CVE_DB_PATH},
    {"name": "NVD_CVE_MATCH", "path": CVE_DB_PATH},
    {"name": "NVD_CVE_CONFIGURATION", "path": CVE_DB_PATH},
    {"name": "NVD_CVE", "path": CVE_DB_PATH},
    {"name": "NVD_CPE", "path": CVE_DB_PATH},
]

REDHAT_KEY_FIELDS_FEEDS = ['CVE', 'bugzilla_description', 'affected_packages']

XML_FEED_NAMESPACES = [
    {'name': '', 'url': 'http://oval.mitre.org/XMLSchema/oval-definitions-5'},
    {'name': 'ind-def', 'url': 'http://oval.mitre.org/XMLSchema/oval-definitions-5#independent'},
    {'name': 'oval', 'url': 'http://oval.mitre.org/XMLSchema/oval-common-5'},
    {'name': 'unix-def', 'url': 'http://oval.mitre.org/XMLSchema/oval-definitions-5#unix'},
    {'name': 'linux-def', 'url': 'http://oval.mitre.org/XMLSchema/oval-definitions-5#linux'}
]

VULNERABILITY_DETECTOR_PREFIX = r'.*wazuh-modulesd:vulnerability-detector.*'

# Test data variables
EXTRA_TEST_DATA = [[1, 2, 3], {"a": 1, "b": 2}, "extra_tag", 12345, "ñ", "テスト", "ИСПЫТАНИЕ", "测试", "اختبار", " ", ""]
EXTRA_TEST_VALUES = [(tag, value) for tag in EXTRA_TEST_DATA for value in EXTRA_TEST_DATA]
EXTRA_TEST_IDS = [f"tag: {value[0]}, value: {value[1]}" for value in EXTRA_TEST_VALUES]

TEST_CHARACTERS = ['.', ':', '@', '#', '*', '-', '_', "'", '"', '/', '=', 'ñ', 'ç', '+', '^', '!', '?', '%', '&', '`',
                   '¿', '?', '(', ')', '|', 'º', '$', '½', '¬', '!', '~', '¡', '[', ']', '{', '}']

CUSTOM_INPUT_TEST_VALUES = [None, "", "dummy value", 12345, ['1', '2', '3', '4', '5'], "ñ", "テスト", "ИСПЫТАНИЕ", "测试",
                            "اختبار"]


def callback_detect_vulnerability_scan_sleeping(line):
    msg = rf'{VULNERABILITY_DETECTOR_PREFIX} Sleeping for (.*)...'
    match = re.match(msg, line)

    return match.group(1) if match is not None else ""


def callback_detect_vulnerability_detector_disabled(line):
    msg = rf'{VULNERABILITY_DETECTOR_PREFIX}DEBUG: Module disabled. Exiting...'
    match = re.match(msg, line)

    return match is not None


def callback_detect_vulnerability_detector_enabled(line):
    msg = r'(.*)wazuh-modulesd:vulnerability-detector(.*)'
    match1 = re.match(msg, line)
    msg = r'(.*)DEBUG: Module disabled. Exiting...(.*)'
    match2 = re.match(msg, line)

    return match1 is not None and match2 is None


def make_vuln_callback(pattern, prefix=VULNERABILITY_DETECTOR_PREFIX):
    """
    Creates a callback function from a text pattern.

    It already contains the vulnerability-detector prefix.

    Parameters
    ----------
    pattern: str
        String to match on the log

    >>> callback_bionic_update_started = make_vuln_callback("Starting Ubuntu Bionic database update")
    """
    pattern = r'\s+'.join(pattern.split())
    regex = re.compile(r'{}{}'.format(prefix, pattern))

    return lambda line: regex.match(line) is not None


def load_db(db_path):
    """Load a database in db_path"""
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    return conn, cursor


def make_query(db_path, query_list):
    """
    Run queries to the database in db_path for each item in query_list.

    Args:
        db_path (string): Path where is located the DB.
        query_list (list): List with queries to run.
    """
    connect = sqlite3.connect(db_path)

    try:
        _make_query(connect, query_list)
    finally:
        connect.close()


def _make_query(connect, query_list):
    """
    Run queries to the database, retrying 5 times in case of operationalError exception.

    Args:
        connect (sqlite3.Connection): Database connection object.
        query_list (list): List with queries to run.
    """
    for _ in range(5):
        try:
            with connect:
                for item in query_list:
                    connect.execute(item)
                break
        except sqlite3.OperationalError:
            sleep(5)


def get_query_result(db_path, query):
    """
    Return the result of a query in a specified DB

    Parameters
    ----------
    db_path: str
        Path to DB
    query: str
        SQL query. (SELECT * ..)

    Return
    ----------------
    result: [[]]
        List of lists where each row is the query result row and each column is the query field value
    """
    try:
        db, cursor = load_db(db_path)
        cursor.execute(query)
        records = cursor.fetchall()
        result = []

        for row in records:
            result.append(', '.join([f'{item}' for item in row]))

        return result

    finally:
        cursor.close()
        db.close()


def clean_table(db_path, table):
    """
    Deletes all entries in a table of a database.
    """
    query_string = f"DELETE FROM {table}"
    make_query(db_path, [query_string])


def clean_vd_tables(agent="000"):
    """
    Clean the tables involved with vuln detector packages and feeds
    """
    tables = [
        {"name": "sys_programs", "path": os.path.join(DB_PATH, f"{agent}.db")},
        {"name": "sys_hotfixes", "path": os.path.join(DB_PATH, f"{agent}.db")},
        {"name": "sys_osinfo", "path": os.path.join(DB_PATH, f"{agent}.db")},
        {"name": "vulnerabilities", "path": CVE_DB_PATH},
        {"name": "vulnerabilities_info", "path": CVE_DB_PATH},
        {"name": "references_info", "path": CVE_DB_PATH},
        {"name": "bugzilla_references_info", "path": CVE_DB_PATH},
        {"name": "advisories_info", "path": CVE_DB_PATH},
        {"name": "metadata", "path": CVE_DB_PATH},
        {"name": "variables", "path": CVE_DB_PATH}
    ]

    # Clean providers and sys_programs tables
    for item in tables:
        try:
            clean_table(item['path'], item['name'])
        except sqlite3.OperationalError:
            pass

    # Clean NVD tables
    for item in NVD_TABLES:
        try:
            clean_table(item['path'], item['name'])
        except sqlite3.OperationalError:
            pass


def update_last_scan(last_scan=0, agent="000"):
    """
    Changes the value of the last scan of an agent.
    """
    path = os.path.join(DB_PATH, f"{agent}.db")
    query_string = f"UPDATE vuln_metadata SET LAST_SCAN={last_scan}"

    make_query(path, [query_string])


def insert_hotfix(agent="000", scan_id=int(time()), scan_time=datetime.datetime.now().strftime("%Y/%m/%d %H:%M:%S"),
                  hotfix="000000", checksum="dummychecksum"):
    path = os.path.join(DB_PATH, f"{agent}.db")
    query_string = f'''INSERT INTO sys_hotfixes
        (scan_id, scan_time, hotfix, checksum)
        VALUES
        ({scan_id}, "{scan_time}", "{hotfix}", "{checksum}")
        '''
    update_last_scan()
    metadata_query_string = f'update vuln_metadata set HOTFIX_SCAN_ID="{scan_id}"'
    make_query(path, [query_string, metadata_query_string])


def insert_osinfo(agent="000", scan_id=int(time()), scan_time=datetime.datetime.now().strftime("%Y/%m/%d %H:%M:%S"),
                  hostname="WINDOWS", architecture="x86_64",
                  os_name="Microsoft Windows Server 2016 Datacenter Evaluation",
                  os_version="10.0.14393", os_major="10", os_minor="0", os_build="14393", version="6.2",
                  os_release="1607", os_patch="0", release="0.0.0", checksum="dummychecksum"):
    path = os.path.join(DB_PATH, f"{agent}.db")
    query_string = f'''INSERT INTO sys_osinfo
        (scan_id, scan_time, hostname, architecture, os_name, os_version, os_major, os_minor, os_patch, os_build,
         release, version, os_release, checksum)
        VALUES
        ("{scan_id}", "{scan_time}", "{hostname}", "{architecture}", "{os_name}", "{os_version}", "{os_major}",
        "{os_minor}", "{os_patch}", "{os_build}", "{release}", "{version}", "{os_release}", "{checksum}")
        '''
    make_query(path, [query_string])


def insert_package(agent="000", scan_id=int(time()), format="rpm", name=DEFAULT_PACKAGE_NAME,
                   priority="", section="Unspecified", size=99, vendor="wazuhintegrationtests", version="1.0.0-1.el7",
                   architecture="x86_64", multiarch="", description="Wazuh Integration tests mock package",
                   source="Wazuh Integration tests mock package", location="", triaged=0,
                   install_time=datetime.datetime.now().strftime("%Y/%m/%d %H:%M:%S"),
                   scan_time=datetime.datetime.now().strftime("%Y/%m/%d %H:%M:%S"), checksum="dummychecksum"):
    """
    Insert a new package in the installed package database, with the parameters given as arguments.
    If used in conjunction with insert_vulnerability using the default arguments it will generate an alert.
    """
    path = os.path.join(DB_PATH, f"{agent}.db")
    query_string = f'''INSERT INTO sys_programs
        (scan_id, scan_time, format, name, priority, section, size, vendor, install_time, version, \
            architecture, multiarch, source, description, location, triaged, checksum)
        VALUES
        ({scan_id}, "{scan_time}", "{format}", "{name}", "{priority}", "{section}", "{size}", "{vendor}",
        "{install_time}", "{version}", "{architecture}", "{multiarch}", "{source}", "{description}",
        "{location}", "{triaged}", "{checksum}")
        '''
    make_query(path, [query_string])


def insert_vulnerability(cveid=DEFAULT_VULNERABILITY_ID, target="RHEL7", target_minor="",
                         package=DEFAULT_PACKAGE_NAME, operation="less than", operation_value="2.0.0-1.el7",
                         title="", severity="critical",
                         published=datetime.datetime.now().strftime("%Y-%m-%dT%H:%M:%SZ"),
                         updated="", reference="https://github.com/wazuh/wazuh-qa", target_v="REDHAT", cvss="10.000000",
                         cvss_vector="AV:N/AC:L/Au:N/C:C/I:C/A:C", rationale="Wazuh integration test vulnerability",
                         CVSS3="", bugzilla_reference="https://github.com/wazuh/wazuh-qa", cwe="WVE-000 -> WVE-001",
                         advisory="RHSA-2010:0029", ref_target="RHEL"):
    """
    Insert a new vulnerability in the database of vulnerabilities, with the parameters given as arguments.
    If used in conjunction with insert_package_in_db using the default arguments it will generate an alert.
    """
    vulnerabilities_query_string = f'''INSERT INTO VULNERABILITIES
        (cveid, target, target_minor, package, operation, operation_value)
        VALUES
        ("{cveid}", "{target}", "{target_minor}", "{package}", "{operation}",
        "{operation_value}")'''
    query_vulnerabilities_info_query_string = f'''INSERT INTO VULNERABILITIES_INFO
        (ID, title, severity, published, updated, target, rationale, cvss, cvss_vector, CVSS3, cwe)
        VALUES
        ("{cveid}", "{title}", "{severity}", "{published}", "{updated}", "{target_v}",
        "{rationale}", "{cvss}", "{cvss_vector}", "{CVSS3}", "{cwe}")
        '''
    query_references_info = f'''INSERT INTO REFERENCES_INFO
        (id, target, reference)
        VALUES
        ("{cveid}", "{ref_target}", "{reference}")
        '''
    query_bugzilla_info = f'''INSERT INTO BUGZILLA_REFERENCES_INFO
        (id, target, bugzilla_reference)
        VALUES
        ("{cveid}", "{ref_target}", "{bugzilla_reference}")
        '''
    query_advisories_info = f'''INSERT INTO ADVISORIES_INFO
        (id, target, advisory)
        VALUES
        ("{cveid}", "{ref_target}", "{advisory}")
        '''

    make_query(CVE_DB_PATH, [vulnerabilities_query_string, query_vulnerabilities_info_query_string,
                             query_references_info, query_bugzilla_info, query_advisories_info])


def update_package(version, package, agent="000"):
    """
    Update version of installed package in database.
    Used to simulate upgrades and downgrades of the package given as argument.
    """
    path = os.path.join(DB_PATH, f"{agent}.db")
    update_query_string = f'UPDATE sys_programs SET version="{version}" WHERE name="{package}"'
    make_query(path, [update_query_string])


def delete_package(package, agent="000"):
    """
    Remove package from database.
    Used to simulate uninstall of the package given as argument or remove a package after a test.
    """
    path = os.path.join(DB_PATH, f"{agent}.db")
    delete_query_string = f'DELETE FROM sys_programs WHERE name="{package}"'
    make_query(path, [delete_query_string])


def delete_vulnerability(cveid):
    """
    Update version of installed package in database.
    Used to simulate uninstall of the package given as argument or remove a package after a test.
    """
    delete_vulnerabilities_query_string = f'DELETE FROM VULNERABILITIES WHERE cveid="{cveid}"'
    delete_vulnerabilities_info_query_string = f'DELETE FROM VULNERABILITIES_INFO WHERE id="{cveid}"'
    delete_references_info_query_string = f'DELETE FROM REFERENCES_INFO WHERE id="{cveid}"'
    delete_bugzilla_info_query_string = f'DELETE FROM BUGZILLA_REFERENCES_INFO WHERE id="{cveid}"'
    delete_advisories_info_query_string = f'DELETE FROM ADVISORIES_INFO WHERE id="{cveid}"'
    make_query(CVE_DB_PATH, [delete_vulnerabilities_query_string, delete_vulnerabilities_info_query_string,
                             delete_references_info_query_string, delete_bugzilla_info_query_string,
                             delete_advisories_info_query_string])


def modify_system(os_name="CentOS Linux", os_major="7", name="centos7", agent_id="000", os_minor="1", os_arch="x86_64",
                  os_version="7.1", os_platform="centos", version="4.0"):
    """
    Modify the system of the manager.
    Used to select the feed that will be used to search vulnerabilities.
    """

    query_string = f'update AGENT set OS_NAME="{os_name}", OS_VERSION="{os_version}", OS_MAJOR="{os_major}", ' \
                   f'OS_MINOR="{os_minor}", OS_ARCH="{os_arch}", NAME="{name}", OS_PLATFORM="{os_platform}", ' \
                   f'VERSION="{version}" WHERE id="{int(agent_id)}"'
    make_query(GLOBAL_DB_PATH, [query_string])


def get_num_vulnerabilities():
    """Get the number of vulnerabilities inserted in VULNERABILITIES table of CVE DB."""
    query_string = f'SELECT count(*) from VULNERABILITIES'
    query_result = get_query_result(CVE_DB_PATH, query_string)
    vulnerabilities_number = int(query_result[0])

    return vulnerabilities_number


def clean_vuln_and_sys_programs_tables(agent='000'):
    """
    Clean vulnerability detector and sys programs table/s

    Parameters
    ----------
    agent: str
        Agent ID
    """
    control_service('stop', daemon='wazuh-db')

    clean_vd_tables(agent)

    sleep(1)

    control_service('start', daemon='wazuh-db')


def insert_custom_package(**kwargs):
    """
    Insert a custom package in sys_programs table

    Parameters
    ----------
    kwargs: dict
        Required arguments of the insert_package function (see its argument list)
    """
    control_service('stop', daemon='wazuh-db')

    insert_package(**kwargs)

    sleep(1)

    control_service('start', daemon='wazuh-db')


def set_custom_system(**kwargs):
    """
    It allows to modify the agent system, modifying the corresponding entry in the agent table of the global.d

    Parameters
    ----------
    kwargs: dict
        Required arguments of the modify_system function (see its argument list)
    """
    control_service('stop', daemon='wazuh-db')

    # Wait until modulesd is restarted to avoid overwriting the system
    sleep(5)

    modify_system(**kwargs)

    control_service('start', daemon='wazuh-db')


def check_vuln_detector_event(wazuh_log_monitor, callback, error_message='', update_position=True,
                              timeout=VULN_DETECTOR_GLOBAL_TIMEOUT, prefix=VULNERABILITY_DETECTOR_PREFIX):
    """
    Check if a vulnerability event  occurs

    Parameters
    ----------
    wazuh_log_monitor: FileMonitor
        FileMonitor object to monitor the Wazuh log
    callback: str
        Log regex to check in Wazuh log
    error_message: str
        Error message to show in case of expected event does not occur
    update_position: boolean
        Filter configuration parameter to search in Wazuh log
    timeout: str
        Timeout to check the event in Wazuh log
    prefix : str
        Log pattern regex
    """
    wazuh_log_monitor.start(
        timeout=timeout,
        update_position=update_position,
        callback=make_vuln_callback(callback, prefix),
        error_message=error_message
    )


def check_vulnerabilities_number(expected_number):
    """
    Check if the number of vulnerabilities inserted in VULNERABILITIES table of CVE DB is the expected.

    Parameters
    ----------
    expected_number: int
        Number of expected vulnerabilities
    """
    vulnerabilities_number = get_num_vulnerabilities()
    assert vulnerabilities_number == expected_number, f"Number of inserted vulnerabilities is not the expected." \
                                                      f" Expected: {expected_number}, Got: {vulnerabilities_number}"


def check_log_event(wazuh_log_monitor, log_event, update_position=False, timeout=VULN_DETECTOR_GLOBAL_TIMEOUT,
                    prefix=VULNERABILITY_DETECTOR_PREFIX):
    """
    Check if the vulnerable package has been reported

    Parameters
    ----------
    wazuh_log_monitor: FileMonitor
        FileMonitor object to monitor the Wazuh log
    log_event: str
        Log event to find in ossec.log
    update_position : boolean
        Filter configuration parameter to search in Wazuh log
    timeout: str
        Timeout to check the event in Wazuh log
    prefix: str
        Log pattern regex
    """
    check_vuln_detector_event(
        wazuh_log_monitor=wazuh_log_monitor, update_position=update_position, timeout=timeout, callback=log_event,
        error_message=f"Could not find the log event: {log_event}", prefix=prefix
    )


def check_feed_imported_successfully(wazuh_log_monitor, log_system_name, expected_vulnerabilities_number,
                                     update_position=False, timeout=VULN_DETECTOR_GLOBAL_TIMEOUT,
                                     check_vuln_number=True):
    """
    Check that redhat OVAL feeds have been imported successfully

    Parameters
    ----------
    wazuh_log_monitor: FileMonitor
        FileMonitor object to monitor the Wazuh log
    log_system_name: str
        System name in ossec log. For instance 'Red Hat Enterprise Linux'
    expected_vulnerabilities_number : int
        Number of expected vulnerabilities imported in the BD
    update_position : boolean
        Filter configuration parameter to search in Wazuh log
    timeout : str
        Timeout to check the event in Wazuh log
    """
    check_vuln_detector_event(
        wazuh_log_monitor=wazuh_log_monitor, update_position=update_position, timeout=timeout,
        callback=rf"INFO: \(\d+\): The update of the '{log_system_name}' feed finished successfully.",
        error_message=f"Could not find the message: '{log_system_name}' feed finished successfully"
    )
    if check_vuln_number:
        check_vulnerabilities_number(expected_number=expected_vulnerabilities_number)


def check_failure_when_importing_feed(wazuh_log_monitor, expected_vulnerabilities_number=0, update_position=False,
                                      timeout=VULN_DETECTOR_GLOBAL_TIMEOUT, parser_error=False):
    """
    Check an error message when importing redhat OVAL feeds and checks that the vulnerabilities table is empty

    Parameters
    ----------
    wazuh_log_monitor: FileMonitor
        FileMonitor object to monitor the Wazuh log
    expected_vulnerabilities_number : int
        Number of expected vulnerabilities imported in the BD
    update_position : boolean
        Filter configuration parameter to search in Wazuh log
    timeout : str
        Timeout to check the event in Wazuh log
    parser_error : boolean
        Check if there is a parser error message
    """
    if parser_error:
        check_log_event(
            wazuh_log_monitor=wazuh_log_monitor, update_position=update_position, timeout=timeout,
            log_event=r"ERROR: \(\d+\): The .* feed couldn't be parsed from .* file"
        )

    check_log_event(
        wazuh_log_monitor=wazuh_log_monitor, update_position=update_position, timeout=timeout,
        log_event=r"ERROR: \(\d+\): CVE database could not be updated."
    )

    check_vulnerabilities_number(expected_number=expected_vulnerabilities_number)


def check_detected_vulnerabilities_number(wazuh_log_monitor, expected_vulnerabilities_number, feed_source,
                                          update_position=False, timeout=VULN_DETECTOR_GLOBAL_TIMEOUT):
    """
    Check the number of vulnerabilities found by the feed source

    Parameters
    ----------
    wazuh_log_monitor: FileMonitor
        FileMonitor object to monitor the Wazuh log
    expected_vulnerabilities_number : int
        Number of expected vulnerabilities
    feed_source : str
        OVAL or NVD
    update_position : boolean
        Filter configuration parameter to search in Wazuh log
    timeout : str
        Timeout to check the event in Wazuh log
    """
    check_vuln_detector_event(
        wazuh_log_monitor=wazuh_log_monitor, update_position=update_position, timeout=timeout,
        callback=f"The {feed_source} found a total of '{expected_vulnerabilities_number}' potential vulnerabilities "
                 "for agent .*",
        error_message=f"The expected number of {feed_source} vulnerabilities have not been found"
    )


def set_system(system):
    """
    Set custom system in global DB Agent info

    Parameters
    ----------
    system: str
        System to set. Available systems in SYSTEM_DATA variable
    """
    try:
        set_custom_system(os_name=SYSTEM_DATA[system]['os_name'], os_major=SYSTEM_DATA[system]['os_major'],
                          os_minor=SYSTEM_DATA[system]['os_minor'], name=SYSTEM_DATA[system]['name'])
    except KeyError:
        pass


def insert_data_json_feed(data, field_name, field_value, append_data):
    """
    Allow insert key:value pair as string, since otherwise, you could not insert lists or dictionaries as a key

     Parameters
    ----------
    data: dict
        Data dictionary
    field_name: str
        Field name to insert
    field_value: str
        Field value to insert
    append_data: dict
        Additional data to insert
    """
    if type(field_name) is str:
        data[field_name] = field_value
        raw_data = json.dumps(data, indent=4, ensure_ascii=False)
    else:
        data['replace_me'] = field_value  # This is necessary to make a non-string field
        raw_data = json.dumps(data, indent=4, ensure_ascii=False).replace('"replace_me"', f"{field_name}")

    if append_data:
        return f"[\n{raw_data},\n{json.dumps(append_data, indent=4, ensure_ascii=False)}\n]"
    else:
        return f"[\n{raw_data}]"


def check_if_modulesd_is_running():
    """
    Check if modulesd daemon is running
    """
    assert check_if_process_is_running('wazuh-modulesd'), "wazuh-modulesd is not running!"


def check_feed_uncompressed_successfully(wazuh_log_monitor, feed, update_position=False,
                                         timeout=VULN_DETECTOR_GLOBAL_TIMEOUT):
    """
    Check that a feed from path or url have been uncompressed successfully

    Parameters
    ----------
    wazuh_log_monitor: FileMonitor
        FileMonitor object to monitor the Wazuh log
    feed: str
        Path or url where the feed is
    update_position : boolean
        Filter configuration parameter to search in Wazuh log
    timeout : str
        Timeout to check the event in Wazuh log
    """
    if feed[-1] == '$':
        feed = feed[:-1]
    prefix = r'.*wazuh-modulesd.*'
    check_vuln_detector_event(
        wazuh_log_monitor=wazuh_log_monitor, update_position=update_position, timeout=timeout,
        callback=rf"(The file|File from URL) '{feed}' was successfully uncompressed into .*",
        error_message=f"Could not find the message: '{feed}' was successfully uncompressed",
        prefix=prefix
    )


def modify_metadata_vuldet_feed(feed, timestamp):
    """Function to modify the timestamp value of the metadata table for a specific feed.

    Args:
        feed (str): The feed name.
        timestamp (str): The new timestamp value to set.
    """
    query_string = f'update METADATA set TIMESTAMP="{timestamp}" where TARGET="{feed}"'
    control_service('stop', daemon='wazuh-db')
    make_query(CVE_DB_PATH, [query_string])
    sleep(1)
    control_service('start', daemon='wazuh-db')


def check_vulnerability_scan_event(wazuh_log_monitor, package, cve):
    """
    Check if inserted vulnerable packages are reported by vulnerability detector.

    Parameters
    ----------
    wazuh_log_monitor: FileMonitor
        FileMonitor object to monitor the Wazuh log
    package: str
        Name of custom package to check. Example: 'firefox-0'
    cve : str
        Package CVE. Example: 'CVE-2019-11764'
    """
    check_vuln_detector_event(
        wazuh_log_monitor=wazuh_log_monitor, timeout=VULN_DETECTOR_SCAN_TIMEOUT, update_position=False,
        callback=f"The '{package}' package .* from agent .* is vulnerable to '{cve}'",
        error_message=f"Could not find the report which says that the package {package} is vulnerable with {cve}",
    )


def restart_modulesd():
    """
    Restart modulesd daemon
    """
    control_service('restart', daemon='wazuh-modulesd')
    sleep(1)


def add_client_keys_entry(agent_id, agent_name, agent_ip='any', agent_key=None):
    """
    Add new entry to client keys file. If the agent_id already exists, this will be overwritten.

    Args:
        agent_id (str): Agent identifier.
        agent_name (str): Agent name.
        agent_ip (str): Agent ip.
        agent_key (str): Agent key.
    """
    registered_client_key_entries_dict = {}

    # Generate new key if necessary
    if agent_key is None:
        agent_key = ''.join(random.choice('0123456789abcdef') for i in range(64))

    # Read client keys data
    with open(CLIENT_KEYS_PATH, 'r') as client_keys:
        registered_client_key_entries_str = client_keys.readlines()

    # Process current client key entries
    for client_key_entry in registered_client_key_entries_str:
        _agent_id, _agent_name, _agent_ip, _agent_key = client_key_entry.split()
        registered_client_key_entries_dict[_agent_id] = f"{_agent_id} {_agent_name} {_agent_ip} {_agent_key}"

    # Add the new client key entry
    registered_client_key_entries_dict[agent_id] = f"{agent_id} {agent_name} {agent_ip} {agent_key}"

    # Save new client keys content
    with open(CLIENT_KEYS_PATH, 'w') as client_keys:
        for _, client_key_entry in registered_client_key_entries_dict.items():
            client_keys.write(f"{client_key_entry}\n")


def delete_client_keys_entry(agent_id):
    """
    Delete an entry from client keys file.

    Args:
        agent_id (str): Agent identifier.
    """
    registered_client_key_entries_dict = {}

    # Read client keys data
    with open(CLIENT_KEYS_PATH, 'r') as client_keys:
        registered_client_key_entries_str = client_keys.readlines()

    # Process current client key entries
    for client_key_entry in registered_client_key_entries_str:
        _agent_id, _agent_name, _agent_ip, _agent_key = client_key_entry.split()
        registered_client_key_entries_dict[_agent_id] = f"{_agent_id} {_agent_name} {_agent_ip} {_agent_key}"

    # Remove client key entry
    registered_client_key_entries_dict.pop(agent_id, None)

    # Save new client keys content
    with open(CLIENT_KEYS_PATH, 'w') as client_keys:
        for _, client_key_entry in registered_client_key_entries_dict.items():
            client_keys.write(f"{client_key_entry}\n")


def create_mocked_agent(name="centos8-agent", ip="127.0.0.1", register_ip="127.0.0.1", internal_key="",
                        os_name="CentOS Linux", os_version="7.1", os_major="7", os_minor="1", os_codename="centos-8",
                        os_build="4.18.0-147.8.1.el8_1.x86_64", os_platform="#1 SMP Thu Apr 9 13:49:54 UTC 2020",
                        os_uname="x86_64", os_arch="x86_64", version="4.2", config_sum="", merged_sum="",
                        manager_host="centos-8", node_name="node01", date_add="1612942494",
                        last_keepalive="253402300799", group="", sync_status="synced", connection_status="active",
                        client_key_secret=None):
    """
    Mock a new agent creating a new client keys entry, adding it to the global db and creating a new agent id DB
    """
    # Get new agent_id
    last_id = get_query_result(GLOBAL_DB_PATH, 'SELECT id FROM agent order by id desc limit 1;')
    agent_id = int(last_id[0][0]) + 1

    query_create_agent = f'''INSERT INTO AGENT
           (id, name, ip, register_ip, internal_key, os_name, os_version, os_major, os_minor,
            os_codename, os_build, os_platform, os_uname, os_arch, version, config_sum, merged_sum,
            manager_host, node_name, date_add, last_keepalive, "group", sync_status, connection_status)
           VALUES
           ( "{agent_id}", "{name}", "{ip}", "{register_ip}", "{internal_key}", "{os_name}", "{os_version}",
             "{os_major}", "{os_minor}", "{os_codename}", "{os_build}", "{os_platform}", "{os_uname}",
             "{os_arch}", "{version}", "{config_sum}", "{merged_sum}", "{manager_host}", "{node_name}",
             "{date_add}", "{last_keepalive}", "{group}", "{sync_status}", "{connection_status}")
           '''

    agent_id_str = str(agent_id).zfill(3)  # Convert from x to 00x

    add_client_keys_entry(agent_id_str, name, ip, client_key_secret)

    # Copy agent db to create a new one
    file.copy(os.path.join(DB_PATH, '000.db'), os.path.join(DB_PATH, f"{agent_id_str}.db"))

    make_query(GLOBAL_DB_PATH, [query_create_agent])

    return agent_id_str


def delete_mocked_agent(agent_id):
    """
    Delete a mocked agent removing it from the global db, client keys and db file
    """
    # Remove from global db
    make_query(GLOBAL_DB_PATH, [f"DELETE FROM agent where id={int(agent_id)}"])

    # Remove agent id DB file
    os.remove(os.path.join(DB_PATH, f"{agent_id}.db"))

    # Remove entry from client keys
    delete_client_keys_entry(agent_id)
