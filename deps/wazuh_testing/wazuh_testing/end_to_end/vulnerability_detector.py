from wazuh_testing.tools.system import HostManager
from wazuh_testing.end_to_end.indexer_api import get_indexer_values

from typing import Dict
import logging
import re


def check_vuln_state_index(host_manager: HostManager, host: str, package: Dict[str, Dict],
                           current_datetime: str = "", return_found: bool = False):
    """
    Check vulnerability state index for a host.

    Args:
        host_manager (HostManager): An instance of the HostManager class containing information about hosts.
        vulnerability_data (dict): Dictionary containing vulnerability data.

    ToDo:
        Implement the functionality.
    """
    index_vuln_state_content = get_indexer_values(host_manager, index='wazuh-states-vulnerabilities',
                                                  greater_than_timestamp=current_datetime)['hits']['hits']
    expected_alerts_not_found = []
    expected_alerts_found = []

    logging.critical(f"Checking vulnerability state index {package}")
    vulnerabilities = package['CVE']

    for vulnerability in vulnerabilities:
        found = False
        for indice_vuln in index_vuln_state_content:
            state_agent = indice_vuln['_source']['agent']['name']
            state_cve = indice_vuln["_source"]['vulnerability']['id']
            state_package_name = indice_vuln['_source']['package']['name']
            state_package_version = indice_vuln['_source']['package']['version']

            if state_agent == host and state_cve == vulnerability \
                and state_package_name == package['package_name'] and \
                    state_package_version == package['package_version']:
                found = True
                expected_alerts_found.append(vulnerability)

        if not found:
            expected_alerts_not_found.append(vulnerability)

    logging.critical(f"Expected alerts not found: {expected_alerts_not_found}")
    logging.critical(f"Triggered alerts: {index_vuln_state_content}")

    if return_found:
        return expected_alerts_found
    else:
        return expected_alerts_not_found


def get_alerts_by_agent(alerts, regex):
    """
    Get specific alerts by agent.

    Args:
        alerts (list): List of alerts.
        regex (str): Regular expression to match the alerts.

    Returns:
        dict: Dictionary containing the alerts by agent.
    """
    alerts_vuln_by_agent = {}

    for alert in alerts:
        if re.match(regex, alert['_source']['rule']['description']):
            if 'agent' in alert['_source']:
                agent = alert['_source']['agent']['name']
                if agent not in alerts_vuln_by_agent:
                    alerts_vuln_by_agent[agent] = []
                alerts_vuln_by_agent[agent].append(alert)

    logging.critical(f"Alerts by agent: {alerts_vuln_by_agent}")
    return alerts_vuln_by_agent


def get_indexed_vulnerabilities_by_agent(indexed_vulnerabilities):
    vulnerabilities_by_agent = {}
    for vulnerabilities_state in indexed_vulnerabilities['hits']['hits']:
        if 'agent' in vulnerabilities_state['_source']:
            agent = vulnerabilities_state['_source']['agent']['name']
            if agent not in vulnerabilities_by_agent:
                vulnerabilities_by_agent[agent] = []

            vulnerabilities_by_agent[agent].append(vulnerabilities_state)

    return vulnerabilities_by_agent


def check_vuln_alert_indexer(host_manager: HostManager, host: str, package: Dict[str, Dict],
                             current_datetime: str = '', vuln_mitigated: bool = False):
    """
    Check vulnerability alerts in the indexer for a host.

    Args:
        host_manager (HostManager): An instance of the HostManager class containing information about hosts.
        vulnerability_data (dict): Dictionary containing vulnerability data.

    Returns:
        list: List of vulnerability alerts.
    """
    logging.critical(f"Checking vulnerability alerts in the indexer {package}")

    regex_to_match = "CVE.* affects .*"
    if vuln_mitigated:
        regex_to_match = "The .* that affected .* was solved due to a package removal"

    indexer_alerts = get_indexer_values(host_manager, greater_than_timestamp=current_datetime)['hits']['hits']
    # Get CVE affects alerts for all agents
    alerts_global = get_alerts_by_agent(indexer_alerts, regex_to_match)

    if host in alerts_global:
        triggered_alerts = alerts_global[host]
    else:
        triggered_alerts = []

    logging.critical(f"Triggered alerts: {triggered_alerts}")

    expected_alerts_not_found = []

    for cve in package['CVE']:
        logging.critical(f"Checking vulnerability: {cve}")

        package_name = package['package_name']
        package_version = package['package_version']

        found = False

        for triggered_alert in triggered_alerts:
            alert_package_name = triggered_alert['_source']['data']['vulnerability']['package']["name"]
            alert_package_version = \
                triggered_alert['_source']['data']['vulnerability']['package']['version']
            alert_cve = triggered_alert['_source']['data']['vulnerability']['cve']

            if alert_cve == cve and alert_package_name == package_name and \
               alert_package_version == package_version:
                found = True

        if not found:
            print(f"Vulnerability not found: {cve} for package {package} {package_version}")
            expected_alerts_not_found.append({'CVE': cve, 'PACKAGE_NAME': package_name,
                                              'PACKAGE_VERSION': package_version})

    logging.critical(f"Expected alerts not found: {expected_alerts_not_found}")
    logging.critical(f"Triggered alerts: {triggered_alerts}")

    return expected_alerts_not_found
