"""
Vulnerability detector module.
-------------------------


Functions:
    - load_packages_metadata: Load packages metadata from the packages.json file.
    - check_vuln_state_index: Check vulnerability state index for a host.


Copyright (C) 2015, Wazuh Inc.
Created by Wazuh, Inc. <info@wazuh.com>.
This program is a free software; you can redistribute it and/or modify it under the terms of GPLv2
"""
import logging
import re
import os
import json
from typing import Dict, List

from wazuh_testing.tools.system import HostManager
from wazuh_testing.end_to_end.indexer_api import get_indexer_values


def load_packages_metadata() -> Dict:
    """
    Load packages metadata from the packages.json file.

    Returns:
        dict: Dictionary containing the packages metadata.

    Example of packages.json:
      "vlc-3.0.11": {
        "package_name": "VLC media player",
        "package_version": "3.0.11",
        "CVE": [
          "CVE-2021-25804",
          "CVE-2021-25803",
          "CVE-2021-25802",
          "CVE-2021-25801",
          "CVE-2020-26664"
        ],
        "url": {
          "windows": {
            "amd64": "https://get.videolan.org/vlc/3.0.11/win64/vlc-3.0.11-win64.exe"
          }
        },
        "uninstall_custom_playbook": "remove_vlc_win.yml"
      },
    """
    packages_filepath = os.path.join(os.path.dirname(__file__),
                                     'vulnerability_detector_packages', 'vuln_packages.json')

    with open(packages_filepath, 'r') as packages_file:
        packages_data = json.load(packages_file)

    return packages_data


def check_vuln_state_index(host_manager: HostManager, host: str, package: Dict[str, Dict],
                           current_datetime: str = "") -> List:
    """
    Check vulnerability state index for a host. This function checks if the vulnerability state index contains the
    expected vulnerabilities for a host. It returns a dictionary containing the expected alerts not found.

    Args:
        host_manager (HostManager): An instance of the HostManager class containing information about hosts.
        host (str): Host name.
        package (dict): Dictionary containing package data.
        current_datetime (str): Datetime to filter the vulnerability state index.
    """
    index_vuln_state_content = get_indexer_values(host_manager, index='wazuh-states-vulnerabilities',
                                                  greater_than_timestamp=current_datetime)['hits']['hits']
    expected_alerts_not_found = []

    logging.info(f"Checking vulnerability state index {package}")
    vulnerabilities = package['CVE']

    for vulnerability in vulnerabilities:
        found = False
        vulnerability_case = {
            'agent': host,
            'cve': vulnerability,
            'package_name': package['package_name'],
            'package_version': package['package_version']
        }

        for indice_vuln in index_vuln_state_content:
            state_agent = indice_vuln['_source']['agent']['name']
            state_cve = indice_vuln["_source"]['vulnerability']['id']
            state_package_name = indice_vuln['_source']['package']['name']
            state_package_version = indice_vuln['_source']['package']['version']

            if state_agent == host and state_cve == vulnerability \
                and state_package_name == package['package_name'] and \
                    state_package_version == package['package_version']:
                found = True
                break

        if not found:
            expected_alerts_not_found.append(vulnerability_case)

    return expected_alerts_not_found


def get_alerts_by_agent(alerts, regex) -> Dict:
    """
    Get specific alerts by agent.

    Args:
        alerts (list): List of alerts.
        regex (str): Regular expression to match the alerts.

    Returns:
        dict: Dictionary containing the alerts by agent.
    """
    alerts_vuln_by_agent = {}

    for alert in alerts:
        if re.match(regex, alert['_source']['rule']['description']):
            if 'agent' in alert['_source']:
                agent = alert['_source']['agent']['name']
                if agent not in alerts_vuln_by_agent:
                    alerts_vuln_by_agent[agent] = []
                alerts_vuln_by_agent[agent].append(alert)

    return alerts_vuln_by_agent


def get_indexed_vulnerabilities_by_agent(indexed_vulnerabilities) -> Dict:
    """Get indexed vulnerabilities by agent.

    Args:
        indexed_vulnerabilities (dict): Dictionary containing the indexed vulnerabilities.

    Returns:
        dict: Dictionary containing the indexed vulnerabilities by agent.
    """
    vulnerabilities_by_agent = {}
    for vulnerabilities_state in indexed_vulnerabilities['hits']['hits']:
        if 'agent' in vulnerabilities_state['_source']:
            agent = vulnerabilities_state['_source']['agent']['name']
            if agent not in vulnerabilities_by_agent:
                vulnerabilities_by_agent[agent] = []

            vulnerabilities_by_agent[agent].append(vulnerabilities_state)

    return vulnerabilities_by_agent


def get_vulnerabilities_alerts_indexer(host_manager: HostManager, host: str, greater_than_timestamp: str = "",
                                       vuln_mitigated=False) -> Dict:
    """Get vulnerabilities alerts by agent.

    Args:
        host_manager (HostManager): An instance of the HostManager class containing information about hosts.
        host (str): Host name.
        greater_than_timestamp (str): Datetime to filter the vulnerability state index.
        vuln_mitigated (bool): Indicates if the vulnerability is mitigated.

    Returns:
        dict: Dictionary containing the indexed vulnerabilities by agent.
    """

    indexer_alerts = get_indexer_values(host_manager, greater_than_timestamp=greater_than_timestamp)['hits']['hits']

    regex_to_match = "CVE.* affects .*" if not vuln_mitigated else \
        "The .* that affected .* was solved due to a package removal"

    return get_alerts_by_agent(indexer_alerts, regex_to_match)


def check_vuln_alert_indexer(vulnerabilities_alerts: Dict, host: str, package: Dict[str, Dict],
                             current_datetime: str = '') -> List:
    """
    Check vulnerability alerts in the indexer for a host.

    Args:
        vulnerabilities_alerts (Dict): Dictionary containing the indexed vulnerabilities by agent.
        host (str): Host name.
        package (dict): Dictionary containing package data.
        vuln_mitigated (bool): Indicates if the vulnerability is mitigated.
        vulnerability_data (dict): Dictionary containing vulnerability data.

    Returns:
        list: List of vulnerability alerts.
    """
    logging.info(f"Checking vulnerability alerts in the indexer {package}")

    # Get CVE affects alerts for all agents
    if host in vulnerabilities_alerts:
        triggered_alerts = vulnerabilities_alerts[host]
    else:
        triggered_alerts = []

    expected_alerts_not_found = []

    for cve in package['CVE']:
        logging.info(f"Checking vulnerability: {cve}")

        package_name = package['package_name']
        package_version = package['package_version']

        found = False

        for triggered_alert in triggered_alerts:
            alert_package_name = triggered_alert['_source']['data']['vulnerability']['package']["name"]
            alert_package_version = \
                triggered_alert['_source']['data']['vulnerability']['package']['version']
            alert_cve = triggered_alert['_source']['data']['vulnerability']['cve']

            if alert_cve == cve and alert_package_name == package_name and \
               alert_package_version == package_version:
                found = True
                break

        if not found:
            logging.info(f"Vulnerability not found: {cve} for package {package} {package_version}")
            expected_alerts_not_found.append({'CVE': cve, 'PACKAGE_NAME': package_name,
                                              'PACKAGE_VERSION': package_version})

    return expected_alerts_not_found
