# Copyright (C) 2015, Wazuh Inc.
# Created by Wazuh, Inc. <info@wazuh.com>.
# This program is a free software; you can redistribute it and/or modify it under the terms of GPLv2

"""
Vulnerability Detector Basic Cases Tests
----------------------------------------

Type: End-to-End (E2E)

Brief:
    This module contains basic tests to ensure the proper functionality of the Vulnerability Detector.
    The tests validate that initial Syscollector scans, along with installation, removal, and uninstall operations,
    trigger Vulnerability Detector scans, generating the expected vulnerabilities.
    The verification of vulnerabilities is conducted through Vulnerabilities Index and API endpoint
    Additionally, the tests ensure the consistency of these values.

Tests:
    - test_syscollector_initial_agent_scan:
        Validates the initiation of Syscollector scans across all agents in the environment.
        Subsequently, it ensures that the Vulnerability Detector detects vulnerabilities within the environment.
        The Agent's Vulnerability Indexer index is expected to be updated with the detected vulnerabilities.

Issue: https://github.com/wazuh/wazuh-qa/issues/4369

Components:
  - vulnerability_detector
  - syscollector

Environment: e2e_vulnerability_detector

Tiers: 0

Markers:
  - e2e
  - vulnerability_detector
  - tier0

ToDo:
    - check_vuln_state_consistency: Function to ensure the consitency of the agent's vulnerabilities
    - Check if wait_until_vuln_scan_agents_finished function works as expected for the second scan
"""
import os
import pytest
import logging
import yaml
import json
import time
import ast
import datetime
from typing import Generator

from wazuh_testing.end_to_end.configuration import backup_configurations, restore_configuration, configure_environment
from wazuh_testing.end_to_end.logs import truncate_remote_host_group_files
from wazuh_testing.end_to_end.waiters import wait_until_vd_is_updated
from wazuh_testing.end_to_end.monitoring import generate_monitoring_logs_all_agent, monitoring_events_multihost
from wazuh_testing.end_to_end.regex import get_event_regex
from wazuh_testing.end_to_end.indexer_api import get_indexer_values
from wazuh_testing.tools.configuration import load_configuration_template
from wazuh_testing.tools.system import HostManager
from wazuh_testing.end_to_end.remote_operations_handler import launch_parallel_operations
from wazuh_testing.end_to_end.vulnerability_detector import get_alerts_by_agent
from wazuh_testing.modules.syscollector import TIMEOUT_SYSCOLLECTOR_SCAN


logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

local_path = os.path.dirname(os.path.abspath(__file__))
current_dir = os.path.dirname(__file__)
configurations_dir = os.path.join(current_dir, "configurations")
configurations_paths = {
        'manager': os.path.join(configurations_dir, 'manager.yaml'),
        'agent': os.path.join(configurations_dir, 'agent.yaml')
        }
vulnerability_detector_logs_dir = os.path.join(current_dir, "logs")


def collect_evidences(host_manager, test_name, evidences_to_collect):
    """
    Collect evidences for the test
    """
    evidences_directory = os.path.join('..', 'logs', test_name)

    print(evidences_directory)

    for evidence, content in evidences_to_collect.items():
        evidence_file = os.path.join(evidences_directory, evidence + ".log")
        with open(evidence_file, 'w') as evidence_file:
            if content.__class__ == dict:
                try:
                    json.dump(content, evidence_file, indent=4)
                except TypeError:
                    logger.critical(f"Error dumping {evidence} to file")
                    pass
            else:
                evidence_file.write(str(content))


def load_vulnerability_detector_configurations(host_manager):
    """Return the configurations for Vulnerability testing for the agent and manager roles

    Return:
        Dict: Configurations for each role
    """
    configurations = {}

    for host in host_manager.get_group_hosts('all'):
        if host in host_manager.get_group_hosts('agent'):
            configurations[host] = load_configuration_template(configurations_paths['agent'], [{}], [{}])
        elif host in host_manager.get_group_hosts('manager'):
            configuration_template = load_configuration_template(configurations_paths['manager'], [{}], [{}])

            # Replace placeholders by real values
            indexer_server = host_manager.get_group_hosts('indexer')[0]
            indexer_server_variables = host_manager.get_host_variables(indexer_server)
            manager_index = host_manager.get_group_hosts('manager').index(host) + 2

            configuration_variables = {
                'INDEXER_USERNAME': indexer_server_variables['indexer_user'],
                'INDEXER_PASSWORD': indexer_server_variables['indexer_password'],
                'INDEXER_SERVER': indexer_server_variables['ip'],
                'FILEBEAT_ROOT_CA': '/etc/pki/filebeat/root-ca.pem',
                'FILEBEAT_CERTIFICATE': f"/etc/pki/filebeat/node-{manager_index}.pem",
                'FILEBEAT_KEY': f"/etc/pki/filebeat/node-{manager_index}-key.pem"
            }
            configuration_template_str = str(configuration_template)

            for key, value in configuration_variables.items():
                configuration_template_str = configuration_template_str.replace(key, value)

            configurations[host] = ast.literal_eval(configuration_template_str)

    return configurations


@pytest.fixture(scope='module')
def setup_vulnerability_tests(host_manager: HostManager) -> Generator:
    """Setup the vulnerability tests environment

    Args:
        host_manager (HostManager): An instance of the HostManager class.
    """
    logger.error("Init setup of environment")

    # Configure managers and agents
    logger.error("Getting backup of current configurations")
    hosts_configuration_backup = backup_configurations(host_manager)
    logger.error("Configuring environment")
    configure_environment(host_manager, load_vulnerability_detector_configurations(host_manager))

    # Truncate alerts and logs of managers and agents
    logger.error("Truncate managers and agents logs")
    truncate_remote_host_group_files(host_manager, 'all', 'logs')

    # Restart managers and stop agents
    logger.error("Stopping agents")
    host_manager.control_environment('stop', ['agent'])
    logger.error("Restarting managers")
    host_manager.control_environment('restart', ['manager'])

    utc_now_timestamp = datetime.datetime.utcnow()

    # Format the date and time as per the given format
    test_timestamp = utc_now_timestamp.strftime("%Y-%m-%dT%H:%M:%SZ")

    # Wait until VD is updated
    logger.error("Wait until Vulnerability Detector has update all the feeds")
    wait_until_vd_is_updated(host_manager)

    # Truncate alerts and logs of managers and agents
    logger.error("Truncate managers and agents logs")
    truncate_remote_host_group_files(host_manager, 'all', 'logs')

    # Re-Register agents: https://github.com/wazuh/wazuh/issues/21185
    logger.error("Removing agents")
    host_manager.remove_agents()

    # Wait until agents are registered again
    time.sleep(15)

    # Start agents
    host_manager.control_environment('start', ['agent'])

    yield test_timestamp

    # Truncate alerts and logs of managers and agents
    logger.error("Truncate managers and agents logs")
    truncate_remote_host_group_files(host_manager, 'all', 'logs')

    logger.error("Restoring original configuration")
    restore_configuration(host_manager, hosts_configuration_backup)

    logger.error("Restarting environment")
    host_manager.control_environment('restart', ['agent'])
    host_manager.control_environment('restart', ['manager'])


def check_vuln_state_consistency(vulnerabilities_alerts, vulnerabilities_states):
    # Get the indexer values
    alerts_vulnerabilities = []
    indices_vulnerabilities = []

    print(vulnerabilities_alerts.__class__)
    for alert in list(vulnerabilities_alerts.values())[0]:
        alert_agent = alert['_source']['agent']['name']
        alert_cve = alert['_source']['data']['vulnerability']['cve']
        alert_package_version = alert['_source']['data']['vulnerability']['package']['version']
        alert_package_name = alert['_source']['data']['vulnerability']['package']['name']
        alerts_vulnerabilities.append({
            'cve': alert_cve,
            'agent': alert_agent,
            'package_name': alert_package_name,
            'package_version': alert_package_version
        })

    for vulnerabilities_state in vulnerabilities_states['hits']['hits']:
        state_agent = vulnerabilities_state['_source']['agent']['name']
        state_cve = vulnerabilities_state['_source']['vulnerability']['id']
        state_package_name = vulnerabilities_state['_source']['package']['name']
        state_package_version = vulnerabilities_state['_source']['package']['version']

        indices_vulnerabilities.append({
            'cve': state_cve,
            'agent': state_agent,
            'package_name': state_package_name,
            'package_version': state_package_version
        })

    if len(alerts_vulnerabilities) != len(indices_vulnerabilities):
        logger.critical("The number of alerts is not the same as the number of states")
        logger.critical(f"Alerts: {len(alerts_vulnerabilities)}")
        logger.critical(f"States: {len(indices_vulnerabilities)}")

    alerts_not_in_state = []
    states_not_in_alerts = []

    # Check that all alerts are in the index
    for alert in alerts_vulnerabilities:
        if alert not in indices_vulnerabilities:
            alerts_not_in_state.append(alert)

    # Check that all index states are in the alerts
    for state in indices_vulnerabilities:
        if state not in alerts_vulnerabilities:
            states_not_in_alerts.append(state)

    return {
        'alerts_not_in_state': alerts_not_in_state,
        'states_not_in_alerts': states_not_in_alerts
        }


@pytest.mark.dependency()
@pytest.mark.filterwarnings('ignore::urllib3.exceptions.InsecureRequestWarning')
def test_syscollector_initial_scans(request, host_manager, setup_vulnerability_tests):
    """
    description: Validates the initiation of Syscollector scans across all agents in the environment.

    This test ensures that the Vulnerability Detector accurately detects vulnerabilities within the environment.
    The Agent's Vulnerability Indexer index is expected to be updated with the detected vulnerabilities.

    tier: 0

    parameters:
        - host_manager:
            type: fixture
            brief: Get the host manager of the environment
        - setup_vulnerability_tests:
            type: fixture
            brief: Setup the environment to proceed with the testing

    assertions:
        - Verify that syscollector scan is started after agent start
        - Verify that Vulnerability scan is performed for all the agent
        - Verify that vulnerabilities are generated for each agent (Check vulnerabilities using Wazuh API)
        - Verify that Agent's Vulnerabilities index is updated and is conssitent with the API results
        - Verify that second scan is performed in expected timeframe
        - Verify that no new vulnearbilities are detected since the first scan

    cases: None

    tags:
        - syscollector
        - vulnerability_detector
    """

    tests_results = {
        'checks': {
            'syscollector_first_scan': True,
            'all_agents_scanned_first_scan': True,
            'all_agents_vulnerabilities_detected': True,
            'index_state_consistent': True,
            'syscollector_second_scan': True,
            'vulnerabilities_equal_between_scans': True,
            'vulnerabilities_equal_between_scans_indexer': True
        },
        'evidences': {
            'agents_not_scanned_first_scan': [],
            'agents_syscollector_scan_not_started': [],
            'agents_syscollector_second_scan_not_started': [],
            'agents_not_detected_vulnerabilities': [],
            'index_state_inconsistencies': {},
            'vulnerabilities_not_equal_between_scans': [],
            'vulnerabilities_not_equal_between_scans_indexer': [],
            'agents_different_between_scans': []
        }
    }
    TIMEOUT_AGENTS_VULNERABILITY_SCAN = 200

    # Monitor for the first Syscollector scan in all the agents
    logger.critical("Monitoring Syscollector First Scan")
    monitoring_data = generate_monitoring_logs_all_agent(host_manager,
                                                         [get_event_regex({'event': 'syscollector_scan_start'}),
                                                          get_event_regex({'event': 'syscollector_scan_end'})],
                                                         [TIMEOUT_SYSCOLLECTOR_SCAN, TIMEOUT_SYSCOLLECTOR_SCAN])

    elements_not_found = monitoring_events_multihost(host_manager, monitoring_data)

    if any(elements_not_found.values()):
        tests_results['checks']['syscollector_first_scan'] = False

        for element in elements_not_found:
            if elements_not_found[element]:
                tests_results['evidences']['agents_syscollector_scan_not_started'].append(element.keys())

        logging.critical(f"Syscollector scan not started in the following agents:"
                         f"{tests_results['evidences']['agents_syscollector_scan_not_started']}."
                         'Continuing with the test')

    # Truncate agents logs to detect second scan
    logger.critical("Truncating agent's logs")
    truncate_remote_host_group_files(host_manager, 'agent', 'logs')

    # Wait until all agents has been scanned
    logger.critical("Waiting until agent's VD scan is over")
    # Replace with relevan event. For now timeout
    time.sleep(TIMEOUT_AGENTS_VULNERABILITY_SCAN)

    logger.critical("Check agent's vulnerabilities")
    alerts_first_scan = get_indexer_values(host_manager,
                                           greater_than_timestamp=setup_vulnerability_tests)['hits']['hits']
    vuln_alerts_by_agent_first_scan = get_alerts_by_agent(alerts_first_scan, 'CVE.*? affects.*"?')


    logger.critical(f"List of alerts first scan: {vuln_alerts_by_agent_first_scan}")


    # Check that it has been triggered vulnerability detector alerts
    logger.critical("Checking that all agents has been scanned")
    for agent in host_manager.get_group_hosts('agent'):
        if agent not in vuln_alerts_by_agent_first_scan.keys():
            logger.critical(f"Agent {agent} has not been scanned. Continuing with remaining agents")
            tests_results['checks']['all_agents_vulnerabilities_detected'] = False
            tests_results['evidences']['agents_not_scanned_first_scan'].append(agent)

        if len(vuln_alerts_by_agent_first_scan[agent]) == 0:
            logger.critical(f"Agent {agent} has not generated vulnerabilities. Continuing with remaining agents")
            tests_results['checks']['all_agents_vulnerabilities_detected'] = False
            tests_results['evidences']['agents_not_detected_vulnerabilities'].append(agent)

    # Check vulnerabilities in the index
    logger.critical("Checking vulnerabilities in the index")
    index_state_first_scan = get_indexer_values(host_manager, index='wazuh-states-vulnerabilities',
                                                greater_than_timestamp=setup_vulnerability_tests)

    logger.critical(f"List of indexer indices  first scan: {vuln_alerts_by_agent_first_scan}")

    # Check that the index is consistent with the alerts
    logging.critical("Checking index state consistency")
    tests_results['evidences']['index_state_inconsistencies'] = \
        check_vuln_state_consistency(vuln_alerts_by_agent_first_scan,
                                     index_state_first_scan)

    if tests_results['evidences']['index_state_inconsistencies']['alerts_not_in_state'] or \
       tests_results['evidences']['index_state_inconsistencies']['states_not_in_alerts']:
        logger.critical("Index state is not consistent with the alerts")
        tests_results['checks']['index_state_consistent'] = False

    # Truncate manager_logs to prevent trigger wait_until_vuln_scan_agents_finished wrongly
    logger.critical("Truncating manager logs")
    truncate_remote_host_group_files(host_manager, 'manager', 'logs')

    logger.critical("Monitoring Second Syscollector scan")
    # The Agent's syscollector second scan is run
    monitoring_data = generate_monitoring_logs_all_agent(host_manager,
                                                         [get_event_regex({'event': 'syscollector_scan_start'}),
                                                          get_event_regex({'event': 'syscollector_scan_end'})],
                                                         [TIMEOUT_SYSCOLLECTOR_SCAN, TIMEOUT_SYSCOLLECTOR_SCAN])

    elements_not_found = monitoring_events_multihost(host_manager, monitoring_data)

    logger.critical("Checking that all agents has been scanned")
    if any(elements_not_found.values()):
        tests_results['checks']['syscollector_second_scan'] = False

        for element in elements_not_found:
            if elements_not_found[element]:
                tests_results['evidences']['agents_syscollector_second_scan_not_started'].append(element.keys())

        logging.critical(f"Syscollector scan not started in the following agents:"
                         f"{tests_results['evidences']['agents_syscollector_second_scan_not_started']}."
                         'Continuing with the test')

    logger.critical("Waiting until agent's VD scan is over")
    time.sleep(60)

    logger.critical("Checking vulnerabilities in the second scan")
    alerts_second_scan = get_indexer_values(host_manager,
                                            greater_than_timestamp=setup_vulnerability_tests)['hits']['hits']

    vuln_alerts_by_agent_second_scan = get_alerts_by_agent(alerts_second_scan, 'CVE.*? affects.*"?')

    alert_present_in_first_scan_not_in_second_scan = []
    alert_present_in_second_scan_not_in_second_scan = []

    if len(vuln_alerts_by_agent_second_scan) != len(vuln_alerts_by_agent_first_scan):
        tests_results['checks']['vulnerabilities_equal_between_scans'] = False
        logger.critical("The number of vulnerabilities is not the same between scans")
        logger.critical(f"First scan: {len(vuln_alerts_by_agent_first_scan)}")
        logger.critical(f"Second scan: {len(vuln_alerts_by_agent_second_scan)}")

    logger.critical("Checking that all agents has been scanned")
    # Check if the number of agents for each scan is the same
    if list(vuln_alerts_by_agent_first_scan.keys()) != list(vuln_alerts_by_agent_second_scan.keys()):
        tests_results['checks']['vulnerabilities_equal_between_scans'] = False
        logging.critical(f"Agents with vulnerabilities changed between scans: "
                         f"First scan: {list(vuln_alerts_by_agent_first_scan.keys())}"
                         f"Second scan: {list(vuln_alerts_by_agent_second_scan.keys())}")
        tests_results['evidences']['agents_different_between_scans'] = \
            list(set(list(vuln_alerts_by_agent_first_scan.keys())) ^ set(list(vuln_alerts_by_agent_second_scan.keys())))

    logger.critical("Checking that all agents has been scanned")
    # Check if the number of vulnerabilities for each agent is the same
    for agent in vuln_alerts_by_agent_second_scan.keys():
        for alert in list(vuln_alerts_by_agent_second_scan[agent][0]):
            alert_present_in_second_scan_not_in_second_scan.append(alert)

        for alert in list(vuln_alerts_by_agent_first_scan[agent][0]):
            if alert in alert_present_in_first_scan_not_in_second_scan:
                alert_present_in_first_scan_not_in_second_scan.remove(alert)

    logger.critical("Checking that all agents has been scanned")
    if alert_present_in_first_scan_not_in_second_scan or alert_present_in_second_scan_not_in_second_scan:
        tests_results['checks']['vulnerabilities_equal_between_scans'] = False
        tests_results['evidences']['vulnerabilities_not_equal_between_scans'] = {
            'alert_present_in_first_scan_not_in_second_scan': alert_present_in_first_scan_not_in_second_scan,
            'alert_present_in_second_scan_not_in_second_scan': alert_present_in_second_scan_not_in_second_scan
        }

    logger.critical("Checking vulnerabilities in the second scan")
    index_state_second_scan = get_indexer_values(host_manager, index='wazuh-states-vulnerabilities',
                                                 greater_than_timestamp=setup_vulnerability_tests)
    logger.critical(f"List of indices second scan: {vuln_alerts_by_agent_second_scan}")

    if index_state_second_scan != index_state_first_scan:
        tests_results['checks']['vulnerabilities_equal_between_scans_indexer'] = False
        tests_results['evidences']['vulnerabilities_not_equal_between_scans_indexer'] = {
            'index_state_first_scan': index_state_first_scan,
            'index_state_second_scan': index_state_second_scan
        }

    test_result = all(tests_results['checks'].values())


    if not test_result:
        logger.critical("Test failed. Test results:")
        if not tests_results['checks']['syscollector_first_scan']:
            logger.critical("Syscollector scan not started in the following agents:"
                            f"{tests_results['evidences']['agents_syscollector_scan_not_started']}")

        if not tests_results['checks']['all_agents_scanned_first_scan']:
            logger.critical("Not all agents were scanned in the first scan. Missing agents:"
                            f"{tests_results['evidences']['agents_not_scanned_first_scan']}")

        if not tests_results['checks']['all_agents_vulnerabilities_detected']:
            logger.critical("Not all agents generated vulnerabilities. Missing agents:"
                            f"{tests_results['evidences']['agents_not_detected_vulnerabilities']}")

        if not tests_results['checks']['index_state_consistent']:
            logger.critical("Index state is not consistent with the alerts. Inconsistencies:"
                            f"{tests_results['evidences']['index_state_inconsistencies']}")

        if not tests_results['checks']['syscollector_second_scan']:
            logger.critical("Syscollector scan not started in the following agents:"
                            f"{tests_results['evidences']['agents_syscollector_second_scan_not_started']}")

        if not tests_results['checks']['vulnerabilities_equal_between_scans']:
            logger.critical("The number of vulnerabilities is not the same between scans. Inconsistencies:"
                            f"{tests_results['evidences']['vulnerabilities_not_equal_between_scans']}")

        if not tests_results['checks']['vulnerabilities_equal_between_scans_indexer']:
            logger.critical("The number of vulnerabilities is not the same between scans. Inconsistencies:"
                            f"{tests_results['evidences']['vulnerabilities_not_equal_between_scans_indexer']}")

        logger.critical("Gathering evidences")

        evidences_to_collect = {
                "alerts_first_scan": vuln_alerts_by_agent_first_scan,
                "alerts_second_scan": vuln_alerts_by_agent_second_scan,
                "index_state_first_scan": index_state_first_scan,
                "index_state_second_scan": index_state_second_scan,
                "index_alerts_inconsistences": tests_results['evidences']['index_state_inconsistencies'],
                "differences_alerts_between_scans":
                tests_results['evidences']['vulnerabilities_not_equal_between_scans'],
                "differences_index_between_scans":
                tests_results['evidences']['vulnerabilities_not_equal_between_scans_indexer']
        }

        collect_evidences(host_manager, request.node.name, evidences_to_collect)

        pytest.fail("Test failed. Check logs for more information")

# -------------------------


cases = {}

with open(os.path.join(current_dir, os.path.join('cases', 'test_vulnerability.yaml')), 'r') as cases_file:
    cases = yaml.load(cases_file, Loader=yaml.FullLoader)

complete_list = [
    (
        case['preconditions'] if 'preconditions' in case else None,
        case['body'] if 'body' in case else None,
        case['teardown'] if 'teardown' in case else None
    )
    for case in cases
]

dependencies = [None if 'depends' not in case else pytest.mark.depends(name=case['id'],
                                                                       depends=case['depends']) for case in cases]
list_ids = [case['id'] for case in cases]


@pytest.mark.dependency()
# @pytest.mark.dependency(depends=["test_syscollector_second_scan"])
@pytest.mark.parametrize('preconditions, body, teardown', complete_list, ids=list_ids)
def test_vulnerability_detector_scans(setup_vulnerability_tests, preconditions, body, teardown, setup, host_manager):

    # Launch tests tasks
    launch_parallel_operations(body['tasks'], host_manager)
