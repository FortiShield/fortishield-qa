# Copyright (C) 2015, Wazuh Inc.
# Created by Wazuh, Inc. <info@wazuh.com>.
# This program is a free software; you can redistribute it and/or modify it under the terms of GPLv2

"""
Vulnerability Detector Basic Cases Tests
----------------------------------------

Type: End-to-End (E2E)

Brief:
    This module contains basic tests to ensure the proper functionality of the Vulnerability Detector.
    The tests validate that initial Syscollector scans, along with installation, removal, and uninstall operations,
    trigger Vulnerability Detector scans, generating the expected vulnerabilities.
    The verification of vulnerabilities is conducted through Vulnerabilities Index and API endpoint
    Additionally, the tests ensure the consistency of these values.

Tests:
    - test_syscollector_initial_agent_scan:
        Validates the initiation of Syscollector scans across all agents in the environment.
        Subsequently, it ensures that the Vulnerability Detector detects vulnerabilities within the environment.
        The Agent's Vulnerability Indexer index is expected to be updated with the detected vulnerabilities.

Issue: https://github.com/wazuh/wazuh-qa/issues/4369

Components:
  - vulnerability_detector
  - syscollector

Environment: e2e_vulnerability_detector

Tiers: 0

Markers:
  - e2e
  - vulnerability_detector
  - tier0

ToDo:
    - check_vuln_state_consistency: Function to ensure the consitency of the agent's vulnerabilities
    - Check if wait_until_vuln_scan_agents_finished function works as expected for the second scan
"""
import os
import pytest
import logging
import yaml
import json
import time
import ast
import datetime
from typing import Generator

from wazuh_testing.end_to_end.configuration import backup_configurations, restore_configuration, configure_environment
from wazuh_testing.end_to_end.logs import truncate_remote_host_group_files
from wazuh_testing.end_to_end.waiters import wait_until_vd_is_updated
from wazuh_testing.end_to_end.monitoring import generate_monitoring_logs, monitoring_events_multihost
from wazuh_testing.end_to_end.regex import get_event_regex
from wazuh_testing.end_to_end.indexer_api import get_indexer_values
from wazuh_testing.tools.configuration import load_configuration_template
from wazuh_testing.tools.system import HostManager
from wazuh_testing.end_to_end.remote_operations_handler import launch_parallel_operations
from wazuh_testing.end_to_end.vulnerability_detector import get_alerts_by_agent, get_indexed_vulnerabilities_by_agent
from wazuh_testing.modules.syscollector import TIMEOUT_SYSCOLLECTOR_SCAN


logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

local_path = os.path.dirname(os.path.abspath(__file__))
current_dir = os.path.dirname(__file__)
configurations_dir = os.path.join(current_dir, "configurations")
configurations_paths = {
        'manager': os.path.join(configurations_dir, 'manager.yaml'),
        'agent': os.path.join(configurations_dir, 'agent.yaml')
        }
vulnerability_detector_logs_dir = os.path.join(current_dir, "logs")
TIMEOUT_PER_AGENT_VULNERABILITY_SCAN = 200


class SyscollectorScansTestsResults:
    """Class to store the results of the Syscollector Scans tests

    Attributes:
        checks (dict): Dictionary with the results of the checks
        evidences (dict): Dictionary with the evidences of the checks
    """
    def __init__(self):
        self.checks = {
            'syscollector_first_scan': True,
            'first_scan_all_agents_alerts_detected': True,
            'first_scan_all_agents_alerts_vulnerabilities': True,
            'first_scan_all_agents_index_detected': True,
            'first_scan_all_agents_index_vulnerabilities': True,
            'index_state_consistent': True,
            'syscollector_second_scan': True,
            'vulnerabilities_equal_between_scans': True,
            'vulnerabilities_equal_between_scans_indexer': True
        }

        self.vulnerabilities_alerts_first_scan = {}
        self.vulnerabilities_alerts_second_scan = {}
        self.vulnerabilities_index_first_scan = {}
        self.vulnerabilities_index_second_scan = {}

        self.timestamp_first_scan = None
        self.timestamp_second_scan = None

        self.evidences = {
                'test_syscollector_first_scan': {
                    'agents_not_scanned_first_scan': [],
                    'testing_evidences_gathering': ["Testing"]
                },
                'test_syscollector_first_scan_alerts': {
                    'agents_not_detected_vulnerabilities': [],
                    'agents_not_scanned_first_scan': [],
                },
                'test_syscollector_first_scan_index': {
                    'agents_not_detected_index_vulnerabilities': [],
                    'agents_not_scanned_index': [],
                },
                'tests_syscollector_vulnerabilities_index_alerts_consistency': {
                    'alerts_not_in_states': [],
                    'states_not_in_alerts': [],
                    'alerts_first_scan': [],
                    'states_first_scan': [],
                },
                'test_syscollector_second_scan': {
                    'agents_not_scanned_second_scan': [],
                },
                'tests_syscollector_first_second_scan_consistency_alerts': {
                    "vulnerabilities_not_equal_between_scans_alerts": [],
                    "agents_different_between_scans": [],
                },
                'tests_syscollector_first_second_scan_consistency_index': {
                    'vulnerabilities_not_equal_between_scans_indexer': [],
                }
        }

    def get_evidences(self):
        return self.evidences

    def summary(self):
        """Print a summary of the results of the tests"""
        if any(self.checks.values()):
            if not self.checks['first_scan_all_agents_alerts_detected']:
                logger.critical("Not all agents generated vulnerabilities. Missing agents:"
                                f"{self.evidences['agents_not_detected_vulnerabilities']}")

            if not self.checks['first_scan_all_agents_alerts_vulnerabilities']:
                logger.critical("Not all agents generated vulnerabilities. Missing agents:"
                                f"{self.evidences['agents_not_detected_vulnerabilities']}")

            if not self.checks['first_scan_all_agents_index_detected']:
                logger.critical("Not all agents were scanned in the index. Missing agents:"
                                f"{self.evidences['agents_not_scanned_index']}")

            if not self.checks['first_scan_all_agents_index_vulnerabilities']:
                logger.critical("Not all agents generated vulnerabilities in the index. Missing agents:"
                                f"{self.evidences['agents_not_detected_index_vulnerabilities']}")

            if not self.checks['index_state_consistent']:
                logger.critical("Index state is not consistent with the alerts."
                                "Inconsistencies can be found in the logs directory")

            if not self.checks['syscollector_second_scan']:
                logger.critical("Syscollector scan not started in the following agents:"
                                f"{self.evidences['agents_syscollector_second_scan_not_started']}")

            if not self.checks['vulnerabilities_equal_between_scans']:
                logger.critical("The number of vulnerabilities alerts is not the same between scans."
                                "Incosistencies can be found in the logs directory")

            if not self.checks['vulnerabilities_equal_between_scans_indexer']:
                logger.critical("The number of vulnerabilities in the index is not the same between scans."
                                "Incosistencies can be found in the logs directory")


@pytest.fixture(scope='module')
def results():
    """
    Handle the results of the tests

    Args:
        host_manager: An instance of the HostManager class containing information about hosts.
    """

    initial_tests_results = SyscollectorScansTestsResults()

    yield initial_tests_results

    initial_tests_results.summary()


def load_vulnerability_detector_configurations(host_manager):
    """Return the configurations for Vulnerability testing for the agent and manager roles

    Return:
        Dict: Configurations for each role
    """
    configurations = {}

    for host in host_manager.get_group_hosts('all'):
        if host in host_manager.get_group_hosts('agent'):
            configurations[host] = load_configuration_template(configurations_paths['agent'], [{}], [{}])
        elif host in host_manager.get_group_hosts('manager'):
            configuration_template = load_configuration_template(configurations_paths['manager'], [{}], [{}])

            # Replace placeholders by real values
            indexer_server = host_manager.get_group_hosts('indexer')[0]
            indexer_server_variables = host_manager.get_host_variables(indexer_server)
            manager_index = host_manager.get_group_hosts('manager').index(host) + 2

            configuration_variables = {
                'INDEXER_USERNAME': indexer_server_variables['indexer_user'],
                'INDEXER_PASSWORD': indexer_server_variables['indexer_password'],
                'INDEXER_SERVER': indexer_server_variables['ip'],
                'FILEBEAT_ROOT_CA': '/etc/pki/filebeat/root-ca.pem',
                'FILEBEAT_CERTIFICATE': f"/etc/pki/filebeat/node-{manager_index}.pem",
                'FILEBEAT_KEY': f"/etc/pki/filebeat/node-{manager_index}-key.pem"
            }
            configuration_template_str = str(configuration_template)

            for key, value in configuration_variables.items():
                configuration_template_str = configuration_template_str.replace(key, value)

            configurations[host] = ast.literal_eval(configuration_template_str)

    return configurations


@pytest.fixture(scope='module')
def setup_vulnerability_tests(host_manager: HostManager) -> Generator:
    """Setup the vulnerability tests environment

    Args:
        host_manager (HostManager): An instance of the HostManager class.
    """
    logger.error("Init setup of environment")

    # Configure managers and agents
    logger.error("Getting backup of current configurations")
    hosts_configuration_backup = backup_configurations(host_manager)
    logger.error("Configuring environment")
    configure_environment(host_manager, load_vulnerability_detector_configurations(host_manager))

    # Truncate alerts and logs of managers and agents
    logger.error("Truncate managers and agents logs")
    truncate_remote_host_group_files(host_manager, 'all', 'logs')

    # Restart managers and stop agents
    logger.error("Stopping agents")
    host_manager.control_environment('stop', ['agent'])
    logger.error("Restarting managers")
    host_manager.control_environment('restart', ['manager'])

    utc_now_timestamp = datetime.datetime.utcnow()

    # Format the date and time as per the given format
    test_timestamp = utc_now_timestamp.strftime("%Y-%m-%dT%H:%M:%SZ")

    # Wait until VD is updated
    logger.error("Wait until Vulnerability Detector has update all the feeds")
    wait_until_vd_is_updated(host_manager)

    # Truncate alerts and logs of managers and agents
    logger.error("Truncate managers and agents logs")
    truncate_remote_host_group_files(host_manager, 'all', 'logs')

    # Re-Register agents: https://github.com/wazuh/wazuh/issues/21185
    logger.error("Removing agents")
    host_manager.remove_agents()

    # Wait until agents are registered again
    time.sleep(15)

    # Start agents
    host_manager.control_environment('start', ['agent'])

    yield test_timestamp

    # Truncate alerts and logs of managers and agents
    logger.error("Truncate managers and agents logs")
    truncate_remote_host_group_files(host_manager, 'all', 'logs')

    logger.error("Restoring original configuration")
    restore_configuration(host_manager, hosts_configuration_backup)

    logger.error("Restarting environment")
    host_manager.control_environment('restart', ['agent'])
    host_manager.control_environment('restart', ['manager'])


def check_vuln_state_consistency(vulnerabilities_alerts, vulnerabilities_states):
    # Get the indexer values
    alerts_vulnerabilities = []
    indices_vulnerabilities = []

    for alert in list(vulnerabilities_alerts.values())[0]:
        alert_agent = alert['_source']['agent']['name']
        alert_cve = alert['_source']['data']['vulnerability']['cve']
        alert_package_version = alert['_source']['data']['vulnerability']['package']['version']
        alert_package_name = alert['_source']['data']['vulnerability']['package']['name']
        alerts_vulnerabilities.append({
            'cve': alert_cve,
            'agent': alert_agent,
            'package_name': alert_package_name,
            'package_version': alert_package_version
        })

    for vulnerabilities_state in list(vulnerabilities_states.values())[0]:
        state_agent = vulnerabilities_state['_source']['agent']['name']
        state_cve = vulnerabilities_state['_source']['vulnerability']['id']
        state_package_name = vulnerabilities_state['_source']['package']['name']
        state_package_version = vulnerabilities_state['_source']['package']['version']

        indices_vulnerabilities.append({
            'cve': state_cve,
            'agent': state_agent,
            'package_name': state_package_name,
            'package_version': state_package_version
        })

    if len(alerts_vulnerabilities) != len(indices_vulnerabilities):
        logger.critical("The number of alerts is not the same as the number of states")
        logger.critical(f"Alerts: {len(alerts_vulnerabilities)}")
        logger.critical(f"States: {len(indices_vulnerabilities)}")

    alerts_not_in_states = []
    states_not_in_alerts = []

    # Check that all alerts are in the index
    for alert in alerts_vulnerabilities:
        if alert not in indices_vulnerabilities:
            alerts_not_in_states.append(alert)

    # Check that all index states are in the alerts
    for state in indices_vulnerabilities:
        if state not in alerts_vulnerabilities:
            states_not_in_alerts.append(state)

    return {
        'alerts_not_in_states': alerts_not_in_states,
        'states_not_in_alerts': states_not_in_alerts
        }


@pytest.mark.filterwarnings('ignore::urllib3.exceptions.InsecureRequestWarning')
class TestInitialScans():
    results = SyscollectorScansTestsResults()

    @pytest.fixture(scope='class')
    def get_results(self):
        return self.results

    def test_syscollector_first_scan(self, host_manager, setup_vulnerability_tests, get_results):
        """
        description: Validates the initiation of Syscollector scans across all agents in the environment.

        This test ensures that the Vulnerability Detector accurately detects vulnerabilities within the environment.
        The Agent's Vulnerability Indexer index is expected to be updated with the detected vulnerabilities.

        tier: 0

        parameters:
            - host_manager:
                type: fixture
                brief: Get the host manager of the environment
            - setup_vulnerability_tests:
                type: fixture
                brief: Setup the environment to proceed with the testing

        assertions:
            - Verify that syscollector scan is started after agent start
            - Verify that Vulnerability scan is performed for all the agent
            - Verify that vulnerabilities are generated for each agent (Check vulnerabilities using Wazuh API)
            - Verify that Agent's Vulnerabilities index is updated and is conssitent with the API results
            - Verify that second scan is performed in expected timeframe
            - Verify that no new vulnearbilities are detected since the first scan

        cases: None

        tags:
            - syscollector
            - vulnerability_detector
        """
        test_fail_message = ""
        results = get_results
        test_name = 'test_syscollector_first_scan'

        logger.critical("Monitoring Syscollector First Scan")
        list_hosts = host_manager.get_group_hosts('agent')
        monitoring_data = generate_monitoring_logs(host_manager,
                                                   [get_event_regex({'event': 'syscollector_scan_start'}),
                                                    get_event_regex({'event': 'syscollector_scan_end'})],
                                                   [TIMEOUT_SYSCOLLECTOR_SCAN, TIMEOUT_SYSCOLLECTOR_SCAN],
                                                   list_hosts)

        monitoring_results = monitoring_events_multihost(host_manager, monitoring_data)

        logger.critical(f"Value of monitoring results is: {monitoring_results}")

        for agent in monitoring_results:
            if monitoring_results[agent]['not_found']:
                results.checks['syscollector_first_scan'] = False
                results.evidences[test_name]['agents_not_scanned_first_scan'].append(agent)
                test_fail_message += "Syscollector scan not started in the following agents:" \
                                     f"{results.evidences['agents_not_scanned_first_scan']}. " \
                                     'Continuing with the test'

        if not results.checks['syscollector_first_scan']:
            pytest.fail(test_fail_message)

    def test_syscollector_first_scan_alerts(self, host_manager, setup_vulnerability_tests, get_results):
        results = get_results
        test_name = 'test_syscollector_first_scan_alerts'

        agents_to_check = results.evidences['test_syscollector_first_scan_alerts']['agents_not_scanned_first_scan']
        if len(agents_to_check) == len(host_manager.get_group_hosts('agent')):
            pytest.skip("Syscollector scan not started in any agent. Skipping test")

        # Wait until all agents has been scanned
        logger.critical("Waiting until agent's VD scan is over")
        # Replace with relevan event. For now timeout
        time.sleep(TIMEOUT_PER_AGENT_VULNERABILITY_SCAN)

        logger.critical("Check agent's vulnerabilities")
        alerts_first_scan = get_indexer_values(host_manager,
                                               greater_than_timestamp=setup_vulnerability_tests)['hits']['hits']
        vuln_alerts_by_agent_first_scan = get_alerts_by_agent(alerts_first_scan, 'CVE.*? affects.*"?')

        results.vulnerabilities_alerts_first_scan = vuln_alerts_by_agent_first_scan

        # Check that it has been triggered vulnerability detector alerts
        logger.critical("Checking that all agents has been scanned")
        for agent in agents_to_check:
            if agent not in list(vuln_alerts_by_agent_first_scan.keys()):
                logger.critical(f"Agent {agent} has not been scanned. Continuing with remaining agents")
                results.checks['first_scan_all_agents_alerts_detected'] = False
                results[test_name]['agents_not_scanned_first_scan'].append(agent)

            if len(vuln_alerts_by_agent_first_scan[agent]) == 0:
                logger.critical(f"Agent {agent} has not generated vulnerabilities. Continuing with remaining agents")
                results.checks['first_scan_all_agents_alerts_vulnerabilities'] = False
                results[test_name]['agents_not_detected_vulnerabilities'].append(agent)

        if not results.checks['first_scan_all_agents_alerts_detected'] or not \
                results.checks['first_scan_all_agents_alerts_vulnerabilities']:
            pytest.fail("Test failed. Check logs for more information")


    def test_syscollector_first_scan_index(self, host_manager, setup_vulnerability_tests, get_results):
        results = get_results
        test_name = 'test_syscollector_first_scan_index'

        agents_to_check = results.evidences['test_syscollector_first_scan_alerts']['agents_not_scanned_first_scan']
        if len(agents_to_check) == len(host_manager.get_group_hosts('agent')):
            pytest.skip("Syscollector scan not started in any agent. Skipping test")

        # Check vulnerabilities in the index
        logger.critical("Checking vulnerabilities in the index")
        index_state_first_scan = get_indexer_values(host_manager, index='wazuh-states-vulnerabilities',
                                                    greater_than_timestamp=setup_vulnerability_tests)
        index_vulnerabilities_by_agent_first_scan = get_indexed_vulnerabilities_by_agent(index_state_first_scan)

        results.vulnerabilities_index_first_scan = index_vulnerabilities_by_agent_first_scan

        logger.critical("Checking that all agents has been scanned and generated vulnerabilities in the index")
        for agent in agents_to_check:
            if agent not in list(index_vulnerabilities_by_agent_first_scan.keys()):
                logger.critical(f"Agent {agent} has not been scanned. Continuing with remaining agents")
                results.checks['first_scan_all_agents_index_detected'] = False
                results[test_name]['agents_not_scanned_index'].append(agent)

            if len(index_vulnerabilities_by_agent_first_scan[agent]) == 0:
                logger.critical(f"Agent {agent} has not generated vulnerabilities. Continuing with remaining agents")
                results.checks['first_scan_all_agents_index_vulnerabilities'] = False
                results[test_name]['agets_not_detected_index_vulnerabilities'].append(agent)

        if not results.checks['first_scan_all_agents_index_detected'] or not \
                results.checks['first_scan_all_agents_index_vulnerabilities']:
            pytest.fail("Test failed. Check logs for more information")

    def tests_syscollector_vulnerabilities_index_alerts_consistency(self, host_manager,
                                                                    setup_vulnerability_tests, get_results):
        results = get_results
        test_name = 'tests_syscollector_vulnerabilities_index_alerts_consistency'

        agents_to_check = results.evidences['test_syscollector_first_scan_alerts']['agents_not_scanned_first_scan']
        if len(agents_to_check) == len(host_manager.get_group_hosts('agent')):
            pytest.skip("Syscollector scan not started in any agent. Skipping test")

        # Check that the index is consistent with the alerts
        logging.critical("Checking index state consistency")
        inconsistencies_between_alerts_indexer = \
            check_vuln_state_consistency(results.vulnerabilities_alerts_first_scan,
                                         results.vulnerabilities_index_first_scan)

        results.evidences[test_name]['alerts_not_in_states'] = \
            inconsistencies_between_alerts_indexer['alerts_not_in_states']
        results.evidences[test_name]['states_not_in_alerts'] = \
            inconsistencies_between_alerts_indexer['states_not_in_alerts']

        if len(results.evidences[test_name]['alerts_not_in_states']) > 0 or \
           len(results.evidences[test_name]['states_not_in_alerts']) > 0:
            logger.critical("Index state is not consistent with the alerts")
            results.checks['index_state_consistent'] = False

        results.evidences[test_name]['alerts_first_scan'] = results.vulnerabilities_alerts_first_scan
        results.evidences[test_name]['states_first_scan'] = results.vulnerabilities_index_first_scan

        if not results.checks['index_state_consistent']:
            pytest.fail("Test failed. Check logs for more information")

    def test_syscollector_second_scan(self, host_manager, setup_vulnerability_tests, get_results):
        results = get_results
        test_name = 'test_syscollector_second_scan'

        agents_to_check = results.evidences['test_syscollector_first_scan_alerts']['agents_not_scanned_first_scan']
        if len(agents_to_check) == len(host_manager.get_group_hosts('agent')):
            pytest.skip("Syscollector scan not started in any agent. Skipping test")

        monitoring_data = generate_monitoring_logs(host_manager,
                                                   [get_event_regex({'event': 'syscollector_scan_start'}),
                                                    get_event_regex({'event': 'syscollector_scan_end'})],
                                                   [TIMEOUT_SYSCOLLECTOR_SCAN, TIMEOUT_SYSCOLLECTOR_SCAN],
                                                   agents_to_check, 2)

        monitoring_results = monitoring_events_multihost(host_manager, monitoring_data)

        logger.critical("Checking that all agents has been scanned")

        for agent in monitoring_results:
            if monitoring_results[agent]['not_found']:
                results.checks['syscollector_second_scan'] = False
                results.evidences[test_name]['agents_syscollector_second_scan_not_started'].append(agent)

                logging.critical(f"Syscollector scan not started in the following agents:"
                                 f"{results.evidences['agents_syscollector_second_scan_not_started']}."
                                 'Continuing with the test')

        if not results.checks['syscollector_second_scan']:
            logger.critical("Syscollector scan not started in the following agents:"
                            f"{results.evidences['agents_syscollector_second_scan_not_started']}.")

            pytest.fail("Test failed. Check logs for more information")

    def tests_syscollector_first_second_scan_consistency_alerts(self, host_manager, setup_vulnerability_tests,
                                                                get_results):
        results = get_results
        test_name = 'tests_syscollector_first_second_scan_consistency_alerts'

        agents_to_check = results.evidences['test_syscollector_first_scan_alerts']['agents_not_scanned_first_scan']
        if len(agents_to_check) == len(host_manager.get_group_hosts('agent')):
            pytest.skip("Syscollector scan not started in any agent. Skipping test")

        logger.critical("Waiting until agent's VD scan is over")
        time.sleep(60)
        logger.critical("Checking vulnerabilities in the second scan")

        alerts_second_scan = get_indexer_values(host_manager,
                                                greater_than_timestamp=setup_vulnerability_tests)['hits']['hits']
        vuln_alerts_by_agent_second_scan = get_alerts_by_agent(alerts_second_scan, 'CVE.*? affects.*"?')
        results.vulnerabilities_alerts_second_scan = vuln_alerts_by_agent_second_scan

        alert_present_in_first_scan_not_in_second_scan = []
        alert_present_in_second_scan_not_in_second_scan = []

        if len(vuln_alerts_by_agent_second_scan) != len(results.vulnerabilities_alerts_first_scan):
            results.checks['vulnerabilities_equal_between_scans'] = False
            logger.critical(f"First scan: {len(results.vulnerabilities_alerts_first_scan)}")
            logger.critical(f"Second scan: {len(vuln_alerts_by_agent_second_scan)}")

        logger.critical("Checking that all agents has been scanned")
        # Check if the number of agents for each scan is the same
        if list(results.vulnerabilities_alerts_first_scan.keys()) != list(vuln_alerts_by_agent_second_scan.keys()):
            results.checks['vulnerabilities_equal_between_scans'] = False
            logging.critical(f"Agents with vulnerabilities changed between scans: "
                             f"First scan: {list(results.vulnerabilities_alerts_first_scan.keys())}"
                             f"Second scan: {list(vuln_alerts_by_agent_second_scan.keys())}")
            results[test_name]['evidences']['agents_different_between_scans'] = \
                list(set(list(results.vulnerabilities_alerts_first_scan.keys())) ^ set(list(vuln_alerts_by_agent_second_scan.keys())))

        logger.critical("Checking that all agents has been scanned")
        # Check if the number of vulnerabilities for each agent is the same
        for agent in agents_to_check:
            for alert in list(vuln_alerts_by_agent_second_scan[agent][0]):
                alert_present_in_second_scan_not_in_second_scan.append(alert)

            for alert in list(results.vulnerabilities_alerts_first_scan[agent][0]):
                if alert in alert_present_in_first_scan_not_in_second_scan:
                    alert_present_in_first_scan_not_in_second_scan.remove(alert)

        logger.critical("Checking that all agents has been scanned")
        if alert_present_in_first_scan_not_in_second_scan or alert_present_in_second_scan_not_in_second_scan:
            results.checks['vulnerabilities_equal_between_scans'] = False
            results.evidences[test_name]['vulnerabilities_not_equal_between_scans_alerts'] = {
                'alert_present_in_first_scan_not_in_second_scan': alert_present_in_first_scan_not_in_second_scan,
                'alert_present_in_second_scan_not_in_second_scan': alert_present_in_second_scan_not_in_second_scan
            }

        if not results.checks['vulnerabilities_equal_between_scans']:
            pytest.fail("Test failed. Check logs for more information")

    def tests_syscollector_first_second_scan_consistency_index(self, host_manager, setup_vulnerability_tests,
                                                               get_results):
        results = get_results
        test_name = 'tests_syscollector_first_second_scan_consistency_index'

        agents_to_check = results.evidences['test_syscollector_first_scan_alerts']['agents_not_scanned_first_scan']
        if len(agents_to_check) == len(host_manager.get_group_hosts('agent')):
            pytest.skip("Syscollector scan not started in any agent. Skipping test")

        logger.critical("Checking vulnerabilities in the second scan")
        index_state_second_scan = get_indexer_values(host_manager, index='wazuh-states-vulnerabilities',
                                                     greater_than_timestamp=setup_vulnerability_tests)
        index_vulnerabilities_by_agent_second_scan = get_indexed_vulnerabilities_by_agent(index_state_second_scan)

        results.vulnerabilities_index_second_scan = index_vulnerabilities_by_agent_second_scan

        differences = list(set(results.vulnerabilities_index_first_scan).symmetric_difference(
            set(results.vulnerabilities_index_second_scan)))

        if results.vulnerabilities_index_first_scan != results.vulnerabilities_index_second_scan:
            results.checks['vulnerabilities_equal_between_scans_indexer'] = False
            results[test_name]['evidences']['vulnerabilities_not_equal_between_scans_indexer'] = differences

            logger.critical("The number of vulnerabilities is not the same between scans")

# -------------------------


cases = {}

with open(os.path.join(current_dir, os.path.join('cases', 'test_vulnerability.yaml')), 'r') as cases_file:
    cases = yaml.load(cases_file, Loader=yaml.FullLoader)

complete_list = [
    (
        case['preconditions'] if 'preconditions' in case else None,
        case['body'] if 'body' in case else None,
        case['teardown'] if 'teardown' in case else None
    )
    for case in cases
]

dependencies = [None if 'depends' not in case else pytest.mark.depends(name=case['id'],
                                                                       depends=case['depends']) for case in cases]
list_ids = [case['id'] for case in cases]

class TestScanSyscollectorCases():
    results = {}

    @pytest.fixture(scope='class')
    def get_results(self):
        return self.results


    @pytest.mark.parametrize('preconditions, body, teardown', complete_list, ids=list_ids)
    #def test_vulnerability_detector_scans_cases(setup_vulnerability_tests, preconditions, body, teardown, setup, host_manager):
    def test_vulnerability_detector_scans_cases(setup_vulnerability_tests, preconditions, body, teardown, setup, host_manager, get_results):
        setup_results = setup
        results = get_results
        hosts_to_ignore = []

        for host in setup_results.keys():
            if setup_results[host]['checks']['all_successfull'] is False:
                hosts_to_ignore.append(host)

        if len(hosts_to_ignore) > 0:
            logger.critical(f"Setup test failed for hosts {hosts_to_ignore}. Check logs for more information")
            logger.critical(f"Evidences: {setup_results}")
            logger.critical("Ignoring these hosts for the rest of the test")

        logger.critical("Starting scan cases tests")
        logger.critical(f"Case Info: {body}")

        # Launch tests tasks
        result = launch_parallel_operations(body['tasks'], host_manager, hosts_to_ignore)

        success_for_all_agents = True

        for host in result.keys():
            if result[host]['checks']['all_successfu1ll'] is False:
                success_for_all_agents = False
                logger.critical(f"Test failed for host {host}. Check logs for more information")
                logger.critical(f"Evidences: {result[host]['evidences']}")

        assert success_for_all_agents is True, "Test failed. Check logs for more information"
