# Copyright (C) 2015, Wazuh Inc.
# Created by Wazuh, Inc. <info@wazuh.com>.
# This program is a free software; you can redistribute it and/or modify it under the terms of GPLv2

"""
Vulnerability Detector Basic Cases Tests
----------------------------------------

Type: End-to-End (E2E)

Brief:
    This module contains basic tests to ensure the proper functionality of the Vulnerability Detector.
    The tests validate that initial Syscollector scans, along with installation, removal, and uninstall operations,
    trigger Vulnerability Detector scans, generating the expected vulnerabilities.
    The verification of vulnerabilities is conducted through Vulnerabilities Index and API endpoint
    Additionally, the tests ensure the consistency of these values.

Tests:
    - test_syscollector_initial_agent_scan:
        Validates the initiation of Syscollector scans across all agents in the environment.
        Subsequently, it ensures that the Vulnerability Detector detects vulnerabilities within the environment.
        The Agent's Vulnerability Indexer index is expected to be updated with the detected vulnerabilities.

Issue: https://github.com/wazuh/wazuh-qa/issues/4369

Components:
  - vulnerability_detector
  - syscollector

Environment: e2e_vulnerability_detector

Tiers: 0

Markers:
  - e2e
  - vulnerability_detector
  - tier0

ToDo:
    - check_vuln_state_consistency: Function to ensure the consitency of the agent's vulnerabilities
    - Check if wait_until_vuln_scan_agents_finished function works as expected for the second scan
"""
import os
import pytest
import logging
import yaml
import time
import re
import ast
from typing import Generator, Dict, List

from wazuh_testing.end_to_end.configuration import backup_configurations, restore_configuration, configure_environment
from wazuh_testing.end_to_end.logs import truncate_remote_host_group_files
from wazuh_testing.end_to_end.wazuh_api import get_agents_vulnerabilities
from wazuh_testing.end_to_end.waiters import wait_until_vd_is_updated, wait_until_vuln_scan_agents_finished
from wazuh_testing.end_to_end.monitoring import generate_monitoring_logs_all_agent, monitoring_events_multihost
from wazuh_testing.end_to_end.regex import get_event_regex
from wazuh_testing.end_to_end.indexer_api import get_indexer_values
from wazuh_testing.tools.configuration import load_configuration_template
from wazuh_testing.tools.system import HostManager
from wazuh_testing.end_to_end.remote_operations_handler import launch_parallel_operations
from wazuh_testing.end_to_end.vulnerability_detector import detect_alerts_by_agent
from wazuh_testing.modules.syscollector import TIMEOUT_SYSCOLLECTOR_SCAN


logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

local_path = os.path.dirname(os.path.abspath(__file__))
current_dir = os.path.dirname(__file__)
configurations_dir = os.path.join(current_dir, "configurations")
configurations_paths = {
        'manager': os.path.join(configurations_dir, 'manager.yaml'),
        'agent': os.path.join(configurations_dir, 'agent.yaml')
        }

def list_of_dicts_to_set_of_tuples(lst):
    """
    Convert a list of dictionaries to a set of frozensets (tuples).
    Each frozenset represents the items of a dictionary.
    """
    return set(frozenset(d.items()) for d in lst)


def load_vulnerability_detector_configurations(host_manager):
    """Return the configurations for Vulnerability testing for the agent and manager roles

    Return:
        Dict: Configurations for each role
    """
    configurations = {}

    for host in host_manager.get_group_hosts('all'):
        if host in host_manager.get_group_hosts('agent'):
            configurations[host] = load_configuration_template(configurations_paths['agent'], [{}], [{}])
        elif host in host_manager.get_group_hosts('manager'):
            configuration_template = load_configuration_template(configurations_paths['manager'], [{}], [{}])

            # Replace placeholders by real values
            indexer_server = host_manager.get_group_hosts('indexer')[0]
            indexer_server_variables = host_manager.get_host_variables(indexer_server)
            manager_index = host_manager.get_group_hosts('manager').index(host) + 2

            configuration_variables = {
                'INDEXER_USERNAME': indexer_server_variables['indexer_user'],
                'INDEXER_PASSWORD': indexer_server_variables['indexer_password'],
                'INDEXER_SERVER': indexer_server_variables['ip'],
                'FILEBEAT_ROOT_CA': '/etc/pki/filebeat/root-ca.pem',
                'FILEBEAT_CERTIFICATE': f"/etc/pki/filebeat/node-{manager_index}.pem",
                'FILEBEAT_KEY': f"/etc/pki/filebeat/node-{manager_index}-key.pem"
            }
            configuration_template_str = str(configuration_template)

            for key, value in configuration_variables.items():
                configuration_template_str = configuration_template_str.replace(key, value)

            configurations[host] = ast.literal_eval(configuration_template_str)

    return configurations


@pytest.fixture(scope='module')
def setup_vulnerability_tests(host_manager: HostManager) -> Generator:
    """Setup the vulnerability tests environment

    Args:
        host_manager (HostManager): An instance of the HostManager class.
    """
    logger.error("Init setup of environment")

    # Configure managers and agents
    logger.error("Getting backup of current configurations")
    hosts_configuration_backup = backup_configurations(host_manager)
    logger.error("Configuring environment")
    configure_environment(host_manager, load_vulnerability_detector_configurations(host_manager))

    # Restart managers and stop agents
    logger.error("Stopping agents")
    host_manager.control_environment('stop', ['agent'])
    logger.error("Restarting managers")
    host_manager.control_environment('restart', ['manager'])

    # Wait until VD is updated
    # To do: Change VD Feeds updated
    logger.error("Wait until Vulnerability Detector has update all the feeds")
    wait_until_vd_is_updated(host_manager)

    # Truncate alerts and logs of managers and agents
    logger.error("Truncate managers and agents logs")
    truncate_remote_host_group_files(host_manager, 'all', 'logs')

    # Start agents
    logger.error("Starting agents")
    host_manager.control_environment('start', ['agent'])

    yield

    # Truncate alerts and logs of managers and agents
    logger.error("Truncate managers and agents logs")
    truncate_remote_host_group_files(host_manager, 'all', 'logs')

    logger.error("Restoring original configuration")
    restore_configuration(host_manager, hosts_configuration_backup)

    logger.error("Restarting environment")
    host_manager.control_environment('restart', ['agent'])
    host_manager.control_environment('restart', ['manager'])


def check_vuln_state_consistency(vulnerabilities_alerts, vulnerabilities_states):
    # Get the indexer values
    alerts_vulnerabilities = []
    indices_vulnerabilities = []

    for vulnerability in vulnerabilities_alerts.values():
        alert_agent = vulnerability['_source']['agent']['name']
        alert_cve = vulnerability['data']['vulnerability']['cve']
        alert_package_version = vulnerability['data']['vulnerability']['package']['version']
        alert_package_name = vulnerability['data']['vulnerability']['package']['name']
        alerts_vulnerabilities.append({
            'cve': alert_cve,
            'agent': alert_agent,
            'package_name': alert_package_name,
            'package_version': alert_package_version
        })


    for vulnerabilities_state in vulnerabilities_states:
        state_agent = vulnerabilities_state['agent']['name']
        state_cve = vulnerabilities_state['vulnerability']['enumeration']
        state_package_name = vulnerabilities_state['package']['name']
        state_package_version = vulnerabilities_state['agent']['version']
        indices_vulnerabilities.append({
            'cve': state_cve,
            'agent': state_agent,
            'package_name': state_package_name,
            'package_version': state_package_version
        })

    indices_vulnerabilities_set = list_of_dicts_to_set_of_tuples(indices_vulnerabilities)
    alerts_vulnerabilities_set = list_of_dicts_to_set_of_tuples(alerts_vulnerabilities)

    # Assert that the sets are equal
    assert indices_vulnerabilities_set == alerts_vulnerabilities_set, "Discrepancies beetween alerts and states indices"


@pytest.mark.dependency()
@pytest.mark.filterwarnings('ignore::urllib3.exceptions.InsecureRequestWarning')
def test_syscollector_initial_scans(host_manager, setup_vulnerability_tests):
    """
    description: Validates the initiation of Syscollector scans across all agents in the environment.

    This test ensures that the Vulnerability Detector accurately detects vulnerabilities within the environment.
    The Agent's Vulnerability Indexer index is expected to be updated with the detected vulnerabilities.

    tier: 0

    parameters:
        - host_manager:
            type: fixture
            brief: Get the host manager of the environment
        - setup_vulnerability_tests:
            type: fixture
            brief: Setup the environment to proceed with the testing

    assertions:
        - Verify that syscollector scan is started after agent start
        - Verify that Vulnerability scan is performed for all the agent
        - Verify that vulnerabilities are generated for each agent (Check vulnerabilities using Wazuh API)
        - Verify that Agent's Vulnerabilities index is updated and is conssitent with the API results
        - Verify that second scan is performed in expected timeframe
        - Verify that no new vulnearbilities are detected since the first scan

    cases: None

    tags:
        - syscollector
        - vulnerability_detector
    """
    TIMEOUT_AGENTS_VULNERABILITY_SCAN = 300

    # Monitor for the first Syscollector scan in all the agents
    logger.critical("Monitoring Syscollector First Scan")
    monitoring_data = generate_monitoring_logs_all_agent(host_manager,
                                                         [get_event_regex({'event': 'syscollector_scan_start'}),
                                                          get_event_regex({'event': 'syscollector_scan_end'})],
                                                         [TIMEOUT_SYSCOLLECTOR_SCAN, TIMEOUT_SYSCOLLECTOR_SCAN])

    monitoring_events_multihost(host_manager, monitoring_data)

    # Truncate agents logs to detect second scan
    logger.critical("Truncating agent's logs")
    truncate_remote_host_group_files(host_manager, 'agent', 'logs')

    # Wait until all agents has been scanned
    logger.critical("Waiting until agent's VD scan is over")

    # ToDo: Replace with relevan event. For now timeout
    time.sleep(TIMEOUT_AGENTS_VULNERABILITY_SCAN)
    # wait_until_vuln_scan_agents_finished(host_manager)

    logger.critical("Check agent's vulnerabilities")

    # Check that each agent has generated alerts
    agents_vuln_first_scan = {}
    indexer_alerts_first_scan = get_indexer_values(host_manager)['hits']['hits']

    vuln_alerts_by_agent_first_scan = detect_alerts_by_agent(indexer_alerts_first_scan, 'CVE. affects.*')

    # Check that it has been triggered vulnerability detector alerts
    for agent in host_manager.get_group_hosts('agent'):
        assert agent not in vuln_alerts_by_agent_first_scan, f"No vulnerabilities were detected for Agent {agent}"
        assert len(vuln_alerts_by_agent_first_scan[agent]) != 0

    # Check index state is not empty
    index_state_first_scan = get_indexer_values(host_manager, index='wazuh-states-vulnerabilities')

    check_vuln_state_consistency(index_state_first_scan, vuln_alerts_by_agent_first_scan)

    # Truncate manager_logs to prevent trigger wait_until_vuln_scan_agents_finished wrongly
    logger.critical("Truncating manager logs")
    truncate_remote_host_group_files(host_manager, 'manager', 'logs')

    logger.critical("Monitoring Second Syscollector scan")
    # The Agent's syscollector second scan is run
    monitoring_data = generate_monitoring_logs_all_agent(host_manager,
                                                         [get_event_regex({'event': 'syscollector_scan_start'}),
                                                          get_event_regex({'event': 'syscollector_scan_end'})],
                                                         [TIMEOUT_SYSCOLLECTOR_SCAN, TIMEOUT_SYSCOLLECTOR_SCAN])

    monitoring_events_multihost(host_manager, monitoring_data)

    # To Do: Replace with relevan event. For now timeout
    time.sleep(300)

    agents_vuln_second_scan = {}
    indexer_alerts_second_scan = get_indexer_values(host_manager)['hits']['hits']
    vuln_alerts_by_agent_second_scan = detect_alerts_by_agent(indexer_alerts_second_scan, 'CVE. affects.*')

    assert vuln_alerts_by_agent_first_scan == vuln_alerts_by_agent_second_scan, \
                                                              "Differences between first and second syscollector" \
                                                              f"First: Scan: {agents_vuln_first_scan}" \
                                                              f"Second Scan: {agents_vuln_second_scan}"

    # Check index state
    index_state_second_scan = get_indexer_values(host_manager, index='wazuh-states-vulnerabilities')
    assert index_state_second_scan == index_state_first_scan, f"Index state value changed between scans: " \
                                                              f"First scan: {index_state_first_scan}" \
                                                              f"Second scan: {index_state_second_scan}"

# -------------------------

cases = {}

with open(os.path.join(current_dir, os.path.join('cases', 'test_vulnerability.yaml')), 'r') as cases_file:
    cases = yaml.load(cases_file, Loader=yaml.FullLoader)

complete_list = [
    (
        case['preconditions'] if 'preconditions' in case else None,
        case['body'] if 'body' in case else None,
        case['teardown'] if 'teardown' in case else None
    )
    for case in cases
]

dependencies = [None if 'depends' not in case else pytest.mark.depends(name=case['id'], depends=case['depends']) for case in cases]
list_ids = [case['id'] for case in cases]


@pytest.mark.dependency()
# @pytest.mark.dependency(depends=["test_syscollector_second_scan"])
@pytest.mark.parametrize('preconditions, body, teardown', complete_list, ids=list_ids)
def test_vulnerability_detector_scans(setup_vulnerability_tests, preconditions, body, teardown, setup, host_manager):

    # Launch tests tasks
    launch_parallel_operations(body['tasks'], host_manager)
