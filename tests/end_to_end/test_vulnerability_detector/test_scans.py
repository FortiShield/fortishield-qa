import pytest
import os
import pytest
import os
import subprocess
import argparse
import ansible_runner
import base64
import re
from multiprocessing.pool import ThreadPool
from wazuh_testing.tools.configuration import (
    load_configuration_template, set_section_wazuh_conf
)
import xml.dom.minidom
import yaml
import tempfile

from wazuh_testing.tools.system import HostManager
from ansible.inventory.manager import InventoryManager
from ansible.parsing.dataloader import DataLoader
from wazuh_testing.tools.monitoring import HostMonitor


current_dir = os.path.dirname(__file__)
configurations_dir = os.path.join(current_dir, "data", "configurations")
cases = {}

with open(os.path.join(current_dir, 'cases.yaml'), 'r') as cases_file:
    cases = yaml.load(cases_file, Loader=yaml.FullLoader)



packages_manager = {
    'centos': 'yum',
    'ubuntu': 'apt'
}

configurations_paths = {
    'manager': os.path.join(configurations_dir, 'manager.yaml'),
    'agent': os.path.join(configurations_dir, 'agent.yaml')
}

configuration_filepath_os = {
    'linux': '/var/ossec/etc/ossec.conf',
    'windows': 'C:\Program Files (x86)\ossec-agent\ossec.conf',
    'macos': '/Library/Ossec/etc/ossec.conf'
}



def get_operation_regex(host, hm, event, operation_data):
    host_os_name = hm.get_host_variables(host)['os'].split('_')[0]
    alert_regex = ''
    if event == 'install_package':
        if host_os_name == 'centos':
            alert_regex = rf".*installed.*agent\".*\"name\":\"{host}\".*Installed: {operation_data['name']}.*{operation_data['version']}"
        elif host_os_name == 'ubuntu':
            alert_regex = rf".*New dpkg \\(Debian Package\\) installed.*.*agent\".*\"name\":\"{host}.*package\":\"{operation_data['name']}\",\"arch\":\"amd64\",\"version\":\"{operation_data['version']}\""
    elif event == 'remove_package':
        if host_os_name == 'centos':
            alert_regex = rf".*package deleted.*agent\".*\"name\":\"{host}\".*Erased: {operation_data['name']}.*{operation_data['version']}"
        elif host_os_name == 'ubuntu':
            alert_regex = rf".*\\(Debian Package\\) removed.*.*agent\".*\"name\":\"{host}.*package\":\"{operation_data['name']}\",\"arch\":\"amd64\",\"version\":\"{operation_data['version']}\""

    elif event == 'update_package':
        if host_os_name == 'centos':
            alert_regex = rf".*package updated.*agent\".*\"name\":\"{host}\".*Updated: {operation_data['name']}.*{operation_data['version']}"
        elif host_os_name == 'ubuntu':
            alert_regex = rf".*New dpkg \\(Debian Package\\) installed.*.*agent\".*\"name\":\"{host}.*package\":\"{operation_data['name']}\",\"arch\":\"amd64\",\"version\":\"{operation_data['version']}\""

    return alert_regex


@pytest.fixture(scope='module')
def get_host_manager(request):
    inventory_path = request.config.getoption('--inventory-path')
    host_manager = HostManager(inventory_path)

    return host_manager, inventory_path


@pytest.fixture(scope='module')
def clean_environment(get_host_manager):
    hm, inventory = get_host_manager

    for host in hm.get_group_hosts('manager'):
        hm.modify_file_content(host, '/var/ossec/logs/alerts/alerts.json', '')


@pytest.fixture(scope='module')
def restart_environment(get_host_manager):
    host_manager, inventory = get_host_manager
    for host in host_manager.get_group_hosts('manager'):
        host_manager.handle_wazuh_services(host, 'restart')

    for host in host_manager.get_group_hosts('agent'):
        host_manager.handle_wazuh_services(host, 'restart')


@pytest.fixture(scope='module', autouse=False)
def configure_environment_manager(get_host_manager):
    def configure_host(host):
        host_variables = host.get_vars()
        host_os = host_variables['os_name']
        configuration_file_path = configuration_filepath_os[host_os]


        host_configuration = None
        host_groups = [str(group) for group in host.get_groups()]
        if 'manager' in host_groups:
            host_configuration = configurations_paths['manager']
        elif 'agent' in host_groups:
            host_configuration = configurations_paths['agent']

        current_configuration = host_manager.get_file_content(str(host), configuration_file_path)
        backup_configurations[host] = current_configuration
        new_configuration_template = load_configuration_template(host_configuration, [{}], [{}])
        new_configuration = set_section_wazuh_conf(new_configuration_template[0].get('sections'), current_configuration.split("\n"))
        new_configuration = [line for line in new_configuration if line.strip() != ""]
        dom = xml.dom.minidom.parseString(''.join(new_configuration))
        new_configuration = "\n".join(dom.toprettyxml().split("\n")[1:])

        host_manager.modify_file_content(str(host), configuration_file_path, new_configuration)

    backup_configurations = {}


    host_manager, inventory  = get_host_manager


    loader = DataLoader()
    inventory_manager = InventoryManager(loader=loader, sources=inventory)
    all_hosts = inventory_manager.get_hosts()


    with ThreadPool() as pool:
        pool.map(configure_host, all_hosts)

    yield

    for host in all_hosts:
        host_variables = host.get_vars()
        host_os = host_variables['os_name']
        configuration_file_path = configuration_filepath_os[host_os]

        host_manager.modify_file_content(str(host), configuration_file_path, backup_configurations[host])

complete_list = [ (case['preconditions'], case['body'], case['teardown']) for case in cases]
list_ids = [ case['id'] for case in cases]


def launch_remote_operation(host, operation, operation_data, hm, inventory):
    print(f"Operation {operation} in {host} with {operation_data}")
    host_os_name = hm.get_host_variables(host)['os'].split('_')[0]
    if operation == 'install_package':
        package_data = operation_data['package']
        package_url = package_data[host_os_name]
        package_manager = packages_manager[host_os_name]
        print(f"Install package {host} {package_url} {package_manager}")
        hm.install_package(host, package_url, package_manager )
    elif operation == 'remove_package':
        package_data = operation_data['package']
        package_name = package_data[host_os_name]
        package_manager = packages_manager[host_os_name]
        hm.remove_package(host, package_name, package_manager )


def launch_remote_sequential_operation_on_agent(agent, task_list, host_manager, inventory):
    if task_list:
        for task in task_list:
            task_keys = list(task.keys())
            task_values = list(task.values())
            operation, operation_data = task_keys[0], task_values[0]
            launch_remote_operation(agent, operation, operation_data, host_manager, inventory)


def launch_parallel_operations(task_list, host_manager, inventory, group='agent'):
    agents = host_manager.get_group_hosts('agent')
    parallel_configuration = [(agent, task_list, host_manager, inventory) for agent in agents]
    with ThreadPool() as pool:
        # Use the pool to map the function to the list of hosts
        pool.starmap(launch_remote_sequential_operation_on_agent, parallel_configuration)


@pytest.fixture(scope='function')
def setup(preconditions, teardown, get_host_manager):
    hm, inventory = get_host_manager
    launch_parallel_operations(preconditions['tasks'], hm, inventory)
    if 'check_alerts' in preconditions:
        temp_file = create_monitoring_file(hm, preconditions['check_alerts'], '/var/ossec/logs/alerts/alerts.json',  120)

        local_path = os.path.dirname(os.path.abspath(__file__))
        tmp_path = os.path.join(local_path, 'tmp')

        HostMonitor(inventory_path=inventory, messages_path=temp_file.name, tmp_path=tmp_path).run()
        temp_file.close()

    yield

    launch_parallel_operations(teardown, hm, inventory)

    for host in hm.get_group_hosts('manager'):
        hm.modify_file_content(host, path='/var/ossec/logs/alerts.json', content='')


def create_monitoring_file(hm, operation_data, monitoring_file, timeout, group='agent'):
    monitoring_file_content = ''
    monitoring_data = {}
    available_events = ['install_package', 'remove_package', 'update_package']

    for host in hm.get_group_hosts(group):
        host_os_name = hm.get_host_variables(host)['os'].split('_')[0]
        for event in operation_data['check_alerts'][host_os_name]:
            event_type = event['event']

            alerts_host = hm.get_host_variables(host)['manager']
            final_regex = get_operation_regex(host, hm, event, operation_data)

            monitoring = {
                'regex': f"{final_regex}",
                'path': f"{monitoring_file}",
                'timeout': f"{timeout}"
            }
            if alerts_host not in monitoring_data:
                monitoring_data[alerts_host] = []

            monitoring_data[alerts_host].append(monitoring)

            for host, data in monitoring_data.items():
                monitoring_file_content += f"""\
    {host}:
"""
            for regex_monitoring in data:
                monitoring_file_content += f"""\
        - regex: "{regex_monitoring['regex']}"
          path: "{regex_monitoring['path']}"
          timeout: {regex_monitoring['timeout']}
"""
        temp_file = tempfile.NamedTemporaryFile()

    with open(temp_file.name, 'w+') as tmp:
        # with tempfile.NamedTemporaryFile(delete=False) as tmp:
        tmp.write(monitoring_file_content)

    return temp_file




@pytest.mark.parametrize('preconditions, body, teardown', complete_list, ids=list_ids)
def test_vulnerability_detector(configure_environment_manager, preconditions, body, teardown, setup, get_host_manager):
    """
    """
    hm, inventory = get_host_manager
    launch_parallel_operations(body['tasks'], hm, inventory)

    temp_file = create_monitoring_file(hm, body['check_alerts'], '/var/ossec/logs/alerts/alerts.json',  120)

    local_path = os.path.dirname(os.path.abspath(__file__))
    tmp_path = os.path.join(local_path, 'tmp')


    HostMonitor(inventory_path=inventory, messages_path=temp_file.name, tmp_path=tmp_path).run()
    temp_file.close()