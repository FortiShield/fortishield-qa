import pytest
import os
import pytest
import os
import subprocess
import argparse
import ansible_runner
import base64
import re
from multiprocessing.pool import ThreadPool
from wazuh_testing.tools.configuration import (
    load_configuration_template, set_section_wazuh_conf
)
import xml.dom.minidom
import yaml
import tempfile

from wazuh_testing.tools.system import HostManager
from ansible.inventory.manager import InventoryManager
from ansible.parsing.dataloader import DataLoader
from wazuh_testing.tools.monitoring import HostMonitor


current_dir = os.path.dirname(__file__)
configurations_dir = os.path.join(current_dir, "data", "configurations")
cases = {}

with open(os.path.join(current_dir, 'cases.yaml'), 'r') as cases_file:
    cases = yaml.load(cases_file, Loader=yaml.FullLoader)



packages_manager = {
    'centos': 'yum',
    'ubuntu': 'apt'
}

configurations_paths = {
    'manager': os.path.join(configurations_dir, 'manager.yaml'),
    'agent': os.path.join(configurations_dir, 'agent.yaml')
}

configuration_filepath_os = {
    'linux': '/var/ossec/etc/ossec.conf',
    'windows': 'C:\Program Files (x86)\ossec-agent\ossec.conf',
    'macos': '/Library/Ossec/etc/ossec.conf'
}

vuln_packages = {
    'centos_7': 'https://downloads.rclone.org/v1.49.5/rclone-v1.49.5-linux-amd64.rpm',
    'ubuntu_22': 'https://downloads.rclone.org/v1.49.5/rclone-v1.49.5-linux-amd64.deb'
}


vuln_packages_uninstall = {
    'centos_7': 'rclone',
    'ubuntu_22': 'rclone'
}


@pytest.fixture(scope='module')
def get_host_manager(request):
    inventory_path = request.config.getoption('--inventory-path')
    host_manager = HostManager(inventory_path)

    return host_manager, inventory_path


@pytest.fixture(scope='module')
def clean_environment(get_host_manager):
    hm, inventory = get_host_manager

    for host in hm.get_group_hosts('manager'):
        hm.modify_file_content(host, '/var/ossec/logs/alerts/alerts.json', '')


@pytest.fixture(scope='module')
def restart_environment(get_host_manager):
    host_manager, inventory = get_host_manager
    for host in host_manager.get_group_hosts('manager'):
        host_manager.handle_wazuh_services(host, 'restart')

    for host in host_manager.get_group_hosts('agent'):
        host_manager.handle_wazuh_services(host, 'restart')


@pytest.fixture(scope='module', autouse=False)
def configure_environment_manager(get_host_manager):
    def configure_host(host):
        host_variables = host.get_vars()
        host_os = host_variables['os_name']
        configuration_file_path = configuration_filepath_os[host_os]


        host_configuration = None
        host_groups = [str(group) for group in host.get_groups()]
        if 'manager' in host_groups:
            host_configuration = configurations_paths['manager']
        elif 'agent' in host_groups:
            host_configuration = configurations_paths['agent']

        current_configuration = host_manager.get_file_content(str(host), configuration_file_path)
        backup_configurations[host] = current_configuration
        new_configuration_template = load_configuration_template(host_configuration, [{}], [{}])
        new_configuration = set_section_wazuh_conf(new_configuration_template[0].get('sections'), current_configuration.split("\n"))
        new_configuration = [line for line in new_configuration if line.strip() != ""]
        dom = xml.dom.minidom.parseString(''.join(new_configuration))
        new_configuration = "\n".join(dom.toprettyxml().split("\n")[1:])

        host_manager.modify_file_content(str(host), configuration_file_path, new_configuration)

    backup_configurations = {}


    host_manager, inventory  = get_host_manager


    loader = DataLoader()
    inventory_manager = InventoryManager(loader=loader, sources=inventory)
    all_hosts = inventory_manager.get_hosts()


    with ThreadPool() as pool:
        pool.map(configure_host, all_hosts)

    yield

    for host in all_hosts:
        host_variables = host.get_vars()
        host_os = host_variables['os_name']
        configuration_file_path = configuration_filepath_os[host_os]

        host_manager.modify_file_content(str(host), configuration_file_path, backup_configurations[host])

complete_list = [ (case['preconditions'], case['body'], case['teardown']) for case in cases]
list_ids = [ case['id'] for case in cases]



def launch_remote_operation(host, operation, operation_data, hm, inventory):
    host_os_name = hm.get_host_variables(host)['os'].split('_')[0]
    if operation == 'install_package':
        package_data = operation_data['package']
        package_url = package_data[host_os_name]
        package_manager = packages_manager[host_os_name]
        print(f"Install package {host} {package_url} {package_manager}")
        hm.install_package(host, package_url, package_manager )
    elif operation == 'remove_package':
        package_data = operation_data['package']
        package_name = package_data[host_os_name]
        package_manager = packages_manager[host_os_name]
        hm.remove_package(host, package_name, package_manager )
    elif operation == 'check_alerts':
        # Check alert
        temp_file = create_monitoring_file(hm.get_host_variables(host)['manager'], operation_data[host_os_name], '/var/ossec/logs/alerts/alerts.json',  120)
        import pdb; pdb.set_trace()
        HostMonitor(inventory_path=inventory, messages_path=temp_file.name, tmp_path='/tmp/').run()
        temp_file.close()


def launch_remote_sequential_operation_on_agent(agent, task_list, host_manager, inventory):
    if task_list:
        for task in task_list:
            task_keys = list(task.keys())
            task_values = list(task.values())
            operation, operation_data = task_keys[0], task_values[0]
            launch_remote_operation(agent, operation, operation_data, host_manager, inventory)


def launch_parallel_operations(task_list, host_manager, inventory, group='agent'):
    agents = host_manager.get_group_hosts('agent')
    parallel_configuration = [(agent, task_list, host_manager, inventory) for agent in agents]
    with ThreadPool() as pool:
        # Use the pool to map the function to the list of hosts
        pool.starmap(launch_remote_sequential_operation_on_agent, parallel_configuration)


@pytest.fixture(scope='function')
def setup(preconditions, teardown, get_host_manager):
    hm, inventory = get_host_manager
    launch_parallel_operations(preconditions, hm, inventory)

    yield

    launch_parallel_operations(teardown, hm, inventory)


def create_monitoring_file(host, regex, monitoring_file, timeout):
    monitoring_file_content = f"""\
{host}:
    - regex: "{regex}"
      path: {monitoring_file}
      timeout: {timeout}
"""

    temp_file = tempfile.NamedTemporaryFile()

    with open(temp_file.name, 'w+') as tmp:
        # with tempfile.NamedTemporaryFile(delete=False) as tmp:
        tmp.write(monitoring_file_content)

    return temp_file



@pytest.mark.parametrize('preconditions, body, teardown', complete_list, ids=list_ids)
def test_vulnerability_detector(configure_environment_manager, preconditions, body, teardown, setup, get_host_manager):
    """
    """
    hm, inventory = get_host_manager
    launch_parallel_operations(body, hm, inventory)
