import os
import pytest
import yaml

from wazuh_testing.tools.configuration import load_configuration_template
from wazuh_testing.end_to_end.configuration import backup_configurations, restore_backup, configure_environment
from wazuh_testing.end_to_end.services import control_environment
from wazuh_testing.end_to_end.logs import truncate_agents_logs, truncate_managers_logs, truncate_logs
from wazuh_testing.end_to_end.wazuh_api import  get_agents_vulnerabilities
from wazuh_testing.end_to_end.waiters import wait_until_vd_is_updated, wait_until_vuln_scan_agents_finished
from wazuh_testing.end_to_end.monitoring import generate_monitoring_logs_all_agent, monitoring_events_multihost
from wazuh_testing.end_to_end.regex import get_event_regex
from wazuh_testing.end_to_end.remote_operations_handler import launch_parallel_operations


TIMEOUT_SYSCOLLECTOR_SCAN = 120

current_dir = os.path.dirname(__file__)
configurations_dir = os.path.join(current_dir, "data", "configurations")
cases = {}
local_path = os.path.dirname(os.path.abspath(__file__))
configurations_paths = {
    'manager': os.path.join(configurations_dir, 'manager.yaml'),
    'agent': os.path.join(configurations_dir, 'agent.yaml')
}
with open(os.path.join(current_dir, 'cases.yaml'), 'r') as cases_file:
    cases = yaml.load(cases_file, Loader=yaml.FullLoader)


complete_list = [
    (
        case['preconditions'] if 'preconditions' in case else None,
        case['body'] if 'body' in case else None,
        case['teardown'] if 'teardown' in case else None
    )
    for case in cases
]

dependencies = [None if 'depends' not in case else pytest.mark.depends(name=case['depend']) for case in cases]
list_ids = [ case['id'] for case in cases]



def load_vulnerability_detector_configurations():
    return {
        'agent': load_configuration_template(configurations_paths['agent'], [{}], [{}]),
        'manager': load_configuration_template(configurations_paths['manager'], [{}], [{}])
    }


@pytest.fixture(scope='module')
def setup_vulnerability_tests(host_manager):
    # Configure managers and agents
    hosts_configuration_backup = backup_configurations(host_manager)
    configure_environment(host_manager, load_vulnerability_detector_configurations())

    # Restart managers and stop agents
    control_environment(host_manager, 'stop', ['agent'])
    control_environment(host_manager, 'restart', ['manager'])

    # Wait until VD is updated
    wait_until_vd_is_updated(host_manager)

    # Truncate alerts and logs of managers and agents
    truncate_logs(host_manager)

    # Start agents
    control_environment(host_manager, 'start', ['agent'])

    yield

    restore_backup(host_manager, hosts_configuration_backup)


def check_vuln_state_index(agents_vulnerabilities_index_value, agents_vulnerabilities_api_value):
    """Check that agents vulnerabilities match with index state values
    """
    # To Do
    pass


@pytest.mark.dependency()
def test_syscollector_initial_scans(host_manager, setup_vulnerability_tests):
    """
    """
    # Monitor for the first Syscollector scan in all the agents
    monitoring_data = generate_monitoring_logs_all_agent(host_manager,
                                                         [get_event_regex({'event': 'syscollector_scan_start'}),
                                                          get_event_regex({'event': 'syscollector_scan_end'})],
                                                          [TIMEOUT_SYSCOLLECTOR_SCAN, TIMEOUT_SYSCOLLECTOR_SCAN])

    monitoring_events_multihost(host_manager, monitoring_data)

    # Truncate agents logs to detect second scan
    truncate_agents_logs(host_manager)

    # Wait until all agents has been scanned
    wait_until_vuln_scan_agents_finished(host_manager)

    # Check vulnerabilities for agent
    agents_vuln_before_second_scan = get_agents_vulnerabilities(host_manager)
    for agent, vuln in agents_vuln_before_second_scan.items():
        assert vuln, f"No vulnerabilities were detected for agent {agent}"

    # Check Agent's System states are stored
    # To Do
    # state_index_content_before_second_scan = get_vuln_state_value(host_manager)

    # Compare agents_vuln_before_second_scan with state_index_content
    # To Do
    # check_vuln_state_index(state_index_content_before_second_scan, agents_vuln_before_second_scan)

    # Truncate manager_logs to prevent trigger wait_until_vuln_scan_agents_finished wrongly
    truncate_managers_logs(host_manager)

    # The Agent's syscollector second scan is run
    monitoring_data = generate_monitoring_logs_all_agent(host_manager,
                                                         [get_event_regex({'event': 'syscollector_scan_start'}),
                                                          get_event_regex({'event': 'syscollector_scan_end'})],
                                                          [TIMEOUT_SYSCOLLECTOR_SCAN, TIMEOUT_SYSCOLLECTOR_SCAN])

    monitoring_events_multihost(host_manager, monitoring_data)

    # WARNING
    # Is possible that second scan will not produce expected Finished Scan in the agent.
    # In that case search for another event or include a hardcoded timeout
    wait_until_vuln_scan_agents_finished(host_manager)

    agents_vuln_after_second_scan = get_agents_vulnerabilities(host_manager)

    assert agents_vuln_before_second_scan == agents_vuln_after_second_scan

    # Check Agent's System states are stored
    # state_index_content_after_second_scan = get_vuln_state_value(host_manager)

    # Compare agents_vuln_before_second_scan with state_index_content
    # To Do
    # check_vuln_state_index(state_index_content_after_second_scan, agents_vuln_before_second_scan)
