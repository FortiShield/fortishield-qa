"""
Pytest Configuration for Wazuh Vulnerability Detector End-to-End Testing

This module contains Pytest fixtures and configuration settings for Wazuh end-to-end testing.
It provides reusable fixtures and setup that can be shared across multiple test modules.

Fixtures:
    - `host_manager`: Fixture for creating a HostManager instance representing the Wazuh test environment.

Configuration Options:
    - `--inventory-path`: Path to the inventory file specifying the test environment hosts.

Example:
    To use the `host_manager` fixture in your test module:

    ```python
    def test_example(host_manager):
        # Your test logic using the host_manager fixture
        pass
    ```
"""
import pytest
import json
import datetime
import os
import shutil
import uuid
from py.xml import html
from numpydoc.docscrape import FunctionDoc

from wazuh_testing.tools.system import HostManager
from wazuh_testing.end_to_end.remote_operations_handler import launch_parallel_operations


catalog = list()
results = dict()

@pytest.fixture(scope='session')
def host_manager(request):
    """Fixture for creating a HostManager instance.

    This fixture initializes and provides a HostManager instance for testing purposes. The HostManager
    is set up at the session scope, ensuring it is created only once for the entire test suite.

    Args:
        request (FixtureRequest): The Pytest fixture request object.

    Returns:
        HostManager: An instance of the HostManager class representing the Wazuh test environment.

    Raises:
        ValueError: If the specified inventory path is invalid or not provided.
    """
    inventory_path = request.config.getoption('--inventory-path')
    host_manager = HostManager(inventory_path)

    return host_manager


@pytest.fixture(scope='function')
def setup(preconditions, teardown, host_manager):
    """
    """
    if preconditions:
        print("Configuyring preconditions")
        launch_parallel_operations(preconditions['tasks'], host_manager)

    yield

    if teardown:
        print("Configuring teardonw")
        launch_parallel_operations(teardown, host_manager)


@pytest.fixture(scope='session', autouse=True)
def handle_logs():

    logs_dir = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'logs')
    os.makedirs(logs_dir, exist_ok=True)

    yield

    shutil.rmtree(logs_dir, ignore_errors=True)


# Configure logging
@pytest.hookimpl(hookwrapper=True, tryfirst=True)
def pytest_runtest_setup(item):
    item_name = item._request.node.name
    logs_dir = os.path.join(os.curdir, 'logs')
    logs_test_dir = os.path.join(logs_dir, item_name)

    os.makedirs(logs_test_dir, exist_ok=True)

    item_log_path = os.path.join('logs', item_name)

    config = item.config
    logging_plugin = config.pluginmanager.get_plugin("logging-plugin")

    filename = os.path.join(item_log_path, item._request.node.name + ".log")

    logging_plugin.set_log_path(str(filename))

    yield


def pytest_html_results_table_header(cells):
    print("Using filename as logging path")
    cells.insert(4, html.th('Tier', class_='sortable tier', col='tier'))
    cells.insert(3, html.th('Markers'))
    cells.insert(2, html.th('Description'))
    cells.insert(1, html.th('Time', class_='sortable time', col='time'))


def pytest_html_results_table_row(report, cells):
    try:
        cells.insert(4, html.td(report.tier))
        cells.insert(3, html.td(report.markers))
        cells.insert(2, html.td(report.description))
        cells.insert(1, html.td(datetime.utcnow(), class_='col-time'))
    except AttributeError:
        pass


# HARDCODE: pytest-html generates too long file names. This temp fix is to reduce the name of
# the assets
def create_asset(
        self, content, extra_index, test_index, file_extension, mode="w"
):
    asset_file_name = "{}.{}".format(
        str(uuid.uuid4()),
        file_extension
    )
    asset_path = os.path.join(
        os.path.dirname(self.logfile), "assets", asset_file_name
    )

    if not os.path.exists(os.path.dirname(asset_path)):
        os.makedirs(os.path.dirname(asset_path))

    relative_path = os.path.join("assets", asset_file_name)

    kwargs = {"encoding": "utf-8"} if "b" not in mode else {}

    with open(asset_path, mode, **kwargs) as f:
        f.write(content)
    return relative_path


@pytest.hookimpl(hookwrapper=True)
def pytest_runtest_makereport(item, call):
    pytest_html = item.config.pluginmanager.getplugin('html')
    outcome = yield
    report = outcome.get_result()
    documentation = FunctionDoc(item.function)

    # Add description, markers and tier to the report
    report.description = '. '.join(documentation["Summary"])
    report.tier = ', '.join(str(mark.kwargs['level']) for mark in item.iter_markers(name="tier"))
    report.markers = ', '.join(mark.name for mark in item.iter_markers() if
                               mark.name != 'tier' and mark.name != 'parametrize')

    if report.location[0] not in results:
        results[report.location[0]] = {'passed': 0, 'failed': 0, 'skipped': 0, 'xfailed': 0, 'error': 0}

    extra = getattr(report, 'extra', [])
    if report.when == 'call':
        # Apply hack to fix length filename problem
        pytest_html.HTMLReport.TestResult.create_asset = create_asset

        # Add extended information from docstring inside 'Result' section
        extra.append(pytest_html.extras.html('<div><h2>Test function details</h2></div>'))
        for section in ('Extended Summary', 'Parameters'):
            extra.append(pytest_html.extras.html(f'<div><h3>{section}</h3></div>'))
            for line in documentation[section]:
                extra.append(pytest_html.extras.html(f'<div>{line}</div>'))
        arguments = dict()

        # Add arguments of each text as a json file
        for key, value in item.funcargs.items():
            if isinstance(value, set):
                arguments[key] = list(value)
            try:
                json.dumps(value)
                arguments[key] = value
            except (TypeError, OverflowError):
                arguments[key] = str(value)
        extra.append(pytest_html.extras.json(arguments, name="Test arguments"))

        # Extra files to be added in 'Links' section
        logs_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'logs', item._request.node.name)

        files = [os.path.join(logs_path, f) for f in os.listdir(logs_path) if
                 os.path.isfile(os.path.join(logs_path, f))]

        import pdb; pdb.set_trace()

        for filepath in files:
            if os.path.isfile(filepath):
                with open(filepath, mode='r', errors='replace') as f:
                    content = f.read()
                    extra.append(pytest_html.extras.text(content, name=os.path.split(filepath)[-1]))

        if not report.passed and not report.skipped:
            report.extra = extra

        if report.longrepr is not None and report.longreprtext.split()[-1] == 'XFailed':
            results[report.location[0]]['xfailed'] += 1
        else:
            results[report.location[0]][report.outcome] += 1

    elif report.outcome == 'failed':
        results[report.location[0]]['error'] += 1


class SummaryTable(html):
    class table(html.table):
        style = html.Style(border='1px solid #e6e6e6', margin='16px 0px', color='#999', font_size='12px')

    class td(html.td):
        style = html.Style(padding='5px', border='1px solid #E6E6E6', text_align='left')

    class th(html.th):
        style = html.Style(padding='5px', border='1px solid #E6E6E6', text_align='left', font_weight='bold')


def pytest_html_results_summary(prefix, summary, postfix):
    postfix.extend([SummaryTable.table(
        html.thead(
            html.tr([
                SummaryTable.th("Tests"),
                SummaryTable.th("Failed"),
                SummaryTable.th("Success"),
                SummaryTable.th("XFail"),
                SummaryTable.th("Error")]
            ),
        ),
        [html.tbody(
            html.tr([
                SummaryTable.td(k),
                SummaryTable.td(v['failed']),
                SummaryTable.td(v['passed']),
                SummaryTable.td(v['xfailed']),
                SummaryTable.td(v['error']),
            ])
        ) for k, v in results.items()])])
