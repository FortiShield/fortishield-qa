'''
copyright: Copyright (C) 2015-2021, Wazuh Inc.

           Created by Wazuh, Inc. <info@wazuh.com>.

           This program is free software; you can redistribute it and/or modify it under the terms of GPLv2

type: integration

brief: Wazuh is able to detect vulnerabilities in the applications installed in agents using the Vulnerability Detector
       module. This software audit is performed through the integration of vulnerability feeds indexed by Redhat,
       Canonical, Debian, Amazon Linux and NVD Database.

tier: 2

modules:
    - vulnerability_detector

components:
    - manager

daemons:
    - wazuh-modulesd
    - wazuh-db
    - wazuh-analysisd

os_platform:
    - linux

os_version:
    - Arch Linux
    - Amazon Linux 2
    - Amazon Linux 1
    - CentOS 8
    - CentOS 7
    - CentOS 6
    - Ubuntu Focal
    - Ubuntu Bionic
    - Ubuntu Xenial
    - Ubuntu Trusty
    - Debian Buster
    - Debian Stretch
    - Debian Jessie
    - Debian Wheezy
    - Red Hat 8
    - Red Hat 7
    - Red Hat 6

references:
    - https://documentation.wazuh.com/current/user-manual/capabilities/vulnerability-detection/
    - https://documentation.wazuh.com/current/user-manual/capabilities/syscollector.html

tags:
    - vulnerability
    - vulnerability_detector
    - feeds
'''
import os
import pytest
from datetime import datetime

from wazuh_testing.tools.configuration import load_configuration_template, get_test_cases_data
import wazuh_testing.tools.file as file

# Marks
pytestmark = pytest.mark.tier(level=2)

# Reference paths
TEST_DATA_PATH = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'data')
CONFIGURATIONS_PATH = os.path.join(TEST_DATA_PATH, 'configuration_template')
TEST_CASES_PATH = os.path.join(TEST_DATA_PATH, 'test_cases')

# Configuration and cases data
configurations_path = os.path.join(CONFIGURATIONS_PATH, 'validate_feed_content.yaml')
t1_cases_path = os.path.join(TEST_CASES_PATH, 'cases_validate_json_feed_content.yaml')
t2_cases_path = os.path.join(TEST_CASES_PATH, 'cases_validate_xml_feed_content.yaml')

# Validate feed content test configurations (t1)
t1_configuration_parameters, t1_configuration_metadata, t1_case_ids = get_test_cases_data(t1_cases_path)

# Add NVD from 2002 to current year configuration
current_year = datetime.now().year
for year in range(2002, current_year):
    t1_configuration_parameters.append(None)
    t1_configuration_metadata.append({'provider_name': 'nvd', 'expected_format': 'application/gzip',
                                      'path': f"/tmp/nvdcve-1.1-{year}.json.gz", 'extension': 'gz',
                                      'url': f"https://nvd.nist.gov/feeds/json/cve/1.1/nvdcve-1.1-{year}.json.gz",
                                      'decompressed_file': f"/tmp/nvd-{year}.json"})
    t1_case_ids.append(f"NVD-{year}")

t1_configurations = load_configuration_template(configurations_path, t1_configuration_parameters,
                                                t1_configuration_metadata)

# Validate feed content test configurations (t2)
t2_configuration_parameters, t2_configuration_metadata, t2_case_ids = get_test_cases_data(t2_cases_path)
t2_configurations = load_configuration_template(configurations_path, t2_configuration_parameters,
                                                t2_configuration_metadata)


def error_message(metadata):
    """Define error messages.

    Return:
        error_file_extension_message (string): String containig the file extension error message.
        error_file_mime_type_message (string): String containig the file mime type error message.
    """
    error_file_extension_message = f"File extension not expected." \
                                   f"Got {file.get_file_info(file_path=metadata['path'], info_type='extension')} " \
                                   f" and expected {metadata['extension']}"

    error_file_mime_type_message = f"File mime type not expected." \
                                   f"Got {file.get_file_info(file_path=metadata['path'], info_type='mime_type')} " \
                                   f"and expected {metadata['expected_format']}"

    return error_file_extension_message, error_file_mime_type_message


@pytest.fixture
def manage_file(metadata, request):
    """Download and clean test files.

    Args:
        feed (dict): Feed information which comes from an element of 'format_feed_data' list
    """
    # Download the file
    file.download_file(source_url=metadata['url'], dest_path=metadata['path'])

    # Decompress files
    if 'application/gzip' in metadata['expected_format']:
        file.decompress_gzip(gzip_file_path=metadata['path'], dest_file_path=metadata['decompressed_file'])
    elif 'application/x-bzip2' in metadata['expected_format']:
        file.decompress_bz2(bz2_file_path=metadata['path'], dest_file_path=metadata['decompressed_file'])

    yield

    # Clean downloaded file/s
    file.remove_file(file_path=metadata['path'])

    if 'application/gzip' in metadata['expected_format'] or 'application/x-bzip2' in metadata['expected_format']:
        file.remove_file(file_path=metadata['decompressed_file'])


@pytest.mark.parametrize('configuration, metadata', zip(t1_configurations, t1_configuration_metadata), ids=t1_case_ids)
def test_validate_json_feed_content(configuration, metadata, manage_file):
    '''
    description: Check if the downloaded feeds have the expected format. To do this, it downloads the feed from URL and
                 check if it is parseable to JSON.

    wazuh_min_version: 4.2.0

    parameters:
        - configuration:
            type: dict
            brief: Wazuh configuration data. Needed for set_wazuh_configuration fixture.
        - metadata:
            type: dict
            brief: Wazuh configuration metadata
        - manage_file:
            type: fixture
            brief: Download and clean test files.

    assertions:
        - Check if the file is JSON parseable.

    input_description:
        - The `cases_validate_redhat_json_feed_content.yaml` file provides the module configuration for this test.

    expected_output:
        - 'File extension not expected.'
        - r'Got .* and expected .*'
        - 'File mime type not expected.'
        - r'.* file is not JSON parseable'

    tags:
        - vulnerability
        - vulnerability_detector
    '''
    error_file_extension_message, error_file_mime_type_message = error_message(metadata)

    if 'decompressed_file' in metadata:
        assert file.get_file_info(file_path=metadata['path'], info_type="extension") == metadata['extension'], \
               error_file_extension_message
        assert file.get_file_info(file_path=metadata['path'], info_type="mime_type") == metadata['expected_format'], \
               error_file_mime_type_message
        assert file.validate_json_file(file_path=metadata['decompressed_file']), f"{metadata['provider_name']} file " \
                                                                                 'is not XML parseable'
    else:
        assert file.validate_json_file(file_path=metadata['path']), f"{metadata['provider_name']} file is not JSON " \
                                                                    'parseable'


@pytest.mark.parametrize('configuration, metadata', zip(t2_configurations, t2_configuration_metadata), ids=t2_case_ids)
def test_validate_xml_feed_content(configuration, metadata, manage_file):
    '''
    description: Check if the downloaded feeds have the expected format. To do this, it downloads the feed from URL and
                 check if it is parseable XML.

    wazuh_min_version: 4.2.0

    parameters:
        - configuration:
            type: dict
            brief: Wazuh configuration data. Needed for set_wazuh_configuration fixture.
        - metadata:
            type: dict
            brief: Wazuh configuration metadata
        - manage_file:
            type: fixture
            brief: Download and clean test files.

    assertions:
        - Check if the file is XML parseable.
        - Check if the file extension is the expected.
        - Check if the file mime type is the expected.

    input_description:
        - The `cases_validate_redhat_xml_feed_content.yaml` file provides the module configuration for this test.

    expected_output:
        - 'File extension not expected.'
        - r'Got .* and expected .*'
        - 'File mime type not expected.'
        - r'.* file is not XML parseable'

    tags:
        - vulnerability
        - vulnerability_detector
    '''
    error_file_extension_message, error_file_mime_type_message = error_message(metadata)

    if 'decompressed_file' in metadata:
        assert file.get_file_info(file_path=metadata['path'], info_type="extension") == metadata['extension'], \
               error_file_extension_message
        assert file.get_file_info(file_path=metadata['path'], info_type="mime_type") == metadata['expected_format'], \
               error_file_mime_type_message
        assert file.validate_xml_file(file_path=metadata['decompressed_file']), f"{metadata['provider_name']} file " \
                                                                                'is not XML parseable'
    else:
        assert file.validate_xml_file(file_path=metadata['path']), f"{metadata['provider_name']} file is not XML " \
                                                                   'parseable'
